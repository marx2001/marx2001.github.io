---
layout: post
title: "vasp计算投影能带"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20250924-pbands/
---

## <center>Vasp计算DOS</center>

　　投影能带的计算不是必需的，而是在分析机制的时候使用。例如在分析晶体场劈裂情况时需要用到。使用名称为《vasp计算能带》文章中所用的INCAR，计算完成后，输入vaspkit/214 即可输出手动选择特定原子的投影能带数据文件。下面是vaspkit投影能带的选取注释：

211    标准能带结构（包含所有原子和轨道的投影）

212    仅提取单个选定原子的轨道投影能带

213    按元素分类（如所有 Fe 原子）的投影能带

214    手动选择特定原子（输入原子序号）的投影能带

215    按元素权重（如 50% Fe + 50% O）的投影能带

216    对选定原子和轨道的投影求和（如所有 Fe 的 d 轨道）


**<span style="font-size: 120%"> 1.Origin绘图（重点）</span>**

以MPSS为例，其结构如图所示

<div align="center"><img src="/img/vasp计算能带/bg-s1.png" alt="MPSS结构图" style="width:500px; height:auto;"/></div>
<div align="center"><img src="/img/vasp计算能带/bg-s2.png" alt="MPSS结构图" style="width:500px; height:auto;"/></div>

vaspkit/214/Mo，绘制Mo原子的投影能带

<div align="center"><img src="/img/vasp计算投影能带/bg-b1.png" alt="第一步" style="width:500px; height:auto;"/></div>

如上图所示，得到数据文件PBAND_SUM_DW.dat和PBAND_SUM_UP.dat文件。删除上图中选中的两行，便于在origin中直接作为标签。

如下图所示，直接将数据文件拖到origin中：

<div align="center"><img src="/img/vasp计算投影能带/bg-b2.png" alt="第一步" style="width:500px; height:auto;"/></div>

选中如图所示两行画图，如下图所示
<div align="center"><img src="/img/vasp计算投影能带/bg-b3.png" alt="b3" style="width:500px; height:auto;"/></div>

双击1，进入图层，选中十个新添加的图层，点击2成组，点击3，修改成散点图

<div align="center"><img src="/img/vasp计算投影能带/bg-b4.png" alt="b3" style="width:500px; height:auto;"/></div>

双击图像（红框区域），弹出来对话框

<div align="center"><img src="/img/vasp计算投影能带/bg-b5.png" alt="b3" style="width:500px; height:auto;"/></div>

修改如下图所示的三个参数，缩放因子建议20。

<div align="center"><img src="/img/vasp计算投影能带/bg-b6.png" alt="b3" style="width:500px; height:auto;"/></div>

注意事项——反铁磁基态，可以任意选择能量折线图，而铁磁基态，由于能带spin up和spin down不简并，所以绘图时要注意，Energy折线图up要选5个（d轨道，p轨道选3个），down要选五个。

原因是投影能带是算的每个轨道相比于Energy的权重，而反铁磁基态的能量是简并的，所以选up和down的均可，不影响权重计算，而铁磁基态由于作为分母的总能量不简并，所以若想准确计算权重，能量折线图（分母）必须一半up一半down。

最终效果图：

<div align="center"><img src="/img/vasp计算投影能带/bg-b7.png" alt="b3" style="width:500px; height:auto;"/></div>


**<span style="font-size: 120%"> 2.自定义脚本绘图（原创）</span>**

这是一个功能强大的，方便自定义任何参数的，类似于vaspkit的脚本，首先要求你的目录结构如下：

```python
你的工作目录/
├── bands/                    # 能带计算目录 (当前运行脚本的目录)
│   ├── KPOINTS              # 能带路径文件 (包含高对称点)
│   ├── POSCAR -> ../POSCAR  # [推荐] 链接到结构文件
│   ├── POTCAR -> ../POTCAR  # [推荐] 链接到赝势文件
│   ├── INCAR                # 能带计算INCAR (ICHARG=11)
│   ├── vasprun.xml          # 能带计算输出
│   ├── PROCAR               # 能带计算投影输出
│   └── plot_fatbands.py     # 脚本文件 (在这里运行)
│
├── dos/                     # DOS计算目录
│   ├── KPOINTS             # DOS K点文件 (通常更密集)
│   ├── POSCAR -> ../POSCAR
│   ├── POTCAR -> ../POTCAR
│   ├── INCAR               # DOS计算INCAR (LORBIT=11)
│   └── vasprun.xml         # DOS计算输出
│
├── POSCAR                  # 晶体结构文件
└── POTCAR                  # 赝势文件 (由所有原子的POTCAR拼接)

```

代码如下：

```python

import numpy as np
import math
import pymatgen
import sys
import argparse
import logging
import time

from pymatgen.io.vasp.outputs import Procar, Vasprun
from pymatgen.io.vasp.inputs import Kpoints
from pymatgen.core import Structure
from pymatgen.electronic_structure.core import Spin, Orbital

import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
from matplotlib.gridspec import GridSpec

# 添加tqdm导入
try:
    from tqdm import tqdm
except ImportError:
    # 如果tqdm不可用，创建空实现
    def tqdm(iterable, **kwargs):
        return iterable

class SaneFormatter(argparse.RawTextHelpFormatter, 
                    argparse.ArgumentDefaultsHelpFormatter):
    pass

parser = argparse.ArgumentParser(prog='plot_fatbands.py',description=("Plot projected band structure (fatbands) from a VASP calculation.\n" +
                                    'Author: Marco Cappelletti. Heavily inspired by Kevin Waters (kwaters4.github.io) and sumo-bandplot.\n' +
                                    'By default is assumes that:\n'  +
                                    '\tthe current directory contains KPOINTS, vasprun.xml from the band calculations\n' +
                                    '\tthe directory ../dos contains vasprun.xml from the dos calculation\n' +
                                    '\tthe parent directory (../) contains the POSCAR file\n' +
                                    '\tthe parent parent directory (../../) contains the POTCAR file\n')
                                    ,formatter_class=SaneFormatter)
parser.add_argument('-b','--vasprun-file-bands', type=str, help='Path of the vasprun.xml file of the band calculation', default='vasprun.xml')
parser.add_argument('-K','--KPOINTS-file', type=str, help='Path of the KPOINTS file with the band path', default='KPOINTS')
parser.add_argument('-c','--POSCAR-file', type=str, help='Path of the POSCAR file', default='../POSCAR')
parser.add_argument('-O','--PROCAR-file', type=str, help='Path of the PROCAR file from the band calculation', default='PROCAR')
parser.add_argument('-w','--POTCAR-file', type=str, help='Path of the POTCAR file', default='../../POTCAR')
parser.add_argument('-d','--vasprun-file-dos', type=str, help='Path of the vasprun.xml file of the dos calculation', default='../dos/vasprun.xml')
parser.add_argument('-p','--project', help='Band projection to rgb. Either 2 (red and green) or 3 arguments (red, green, blue). Nomenclature:\n'
                                                    '\t- E: all orbitals of element E (H, C, N, O, ...)\n'
                                                    '\t- E.o: o-orbital of element E (s, px, py, pz, dxy, ...)\n'
                                                    '\t- E.s.pz: s+pz orbitals of element E\n'
                                                    '\t- X.s: s orbitals of all elements\n'
                                                    '\t- O.s.pz+N.pz: sum of O(s,pz) and N(pz)\n', nargs='+', default=['X.px', 'X.py', 'X.s.pz'])
parser.add_argument('-n','--normalization', type=str, help=f'Normalization of the projection.\n'
                                                    '\t-\'all\': with respect to all contributions.\n'
                                                    '\t-\'selection\': with respect to selection only\n', choices=['all','selection'], default='selection')
parser.add_argument('-l','--max-l',type=int,default=1,choices=[1,2,3],help='Maximum value of l (angular momemtum) for the projection. Increases computational costs, so increase it only if necessary.')
parser.add_argument('-e','--emin', type=float, help='Minimum of energy in the plot. If none, it chooses the lower limit', default=None)
parser.add_argument('-E','--emax', type=float, help='Maximum of energy in the plot. If none, it chooses the upper limit', default=None)
parser.add_argument('-s','--scale', type=float, help='DOS scale factor', default=2.0)
parser.add_argument('-H','--height', type=float, help='Height of the plot in inches', default=3.5)
parser.add_argument('-W','--width', type=float, help='Width of the plot in inches', default=3.3)
parser.add_argument('-r','--ratio', type=float, help='Bandplot - dosplot width ratio', default=3.0)
parser.add_argument('-f','--font-size', type=float, help='Fontsize', default=8)
parser.add_argument('-o','--output-file', type=str, help='Path and name of the output file, excluding the format', default='fatbands')
parser.add_argument('--format', type=str, help='Output file format', choices=['pdf','png'], default='pdf')
# 添加轨道气泡图参数
parser.add_argument('--element', type=str, help='Element for orbital bubble plot (e.g., Fe)', default=None)
parser.add_argument('--orbital-type', type=str, choices=['d', 'p'], help='Type of orbital to plot (d or p)', default='d')
parser.add_argument('--bubble-min', type=float, help='Minimum bubble size', default=0.05)
parser.add_argument('--bubble-max', type=float, help='Maximum bubble size', default=0.3)
parser.add_argument('--bubble-scale', type=float, help='Bubble size scaling factor', default=100)
parser.add_argument('--bubble-density', type=int, help='Bubble density (1: every point, 2: every second point, etc.)', default=5)
parser.add_argument('--bubble-threshold', type=float, help='Minimum weight to plot bubble', default=0.05)

args = parser.parse_args()
scale=args.scale

logging.basicConfig(
    filename="plot_fatbands.log",
    level=logging.INFO,
    filemode="w",
    format="%(message)s",
)

logging.info(" ".join(sys.argv[:]))

# plot colored line. Function written by Kevin Waters
def rgbline(ax, k, e, red, green, blue, KPOINTS, alpha=1.):
    #creation of segments based on
    #http://nbviewer.ipython.org/urls/raw.github.com/dpsanders/matplotlib-examples/master/colorline.ipynb
    pts = np.array([KPOINTS, e]).T.reshape(-1, 1, 2)
    seg = np.concatenate([pts[:-1], pts[1:]], axis=1)
    nseg = len(KPOINTS) -1
    a = np.ones(nseg, np.float64)*alpha
    lc = LineCollection(seg, colors=list(zip(red,green,blue,a)), linewidth = 2)
    ax.add_collection(lc)


if __name__ == "__main__":
    # Load Structure
    structure = Structure.from_file(args.POSCAR_file)
    atom_labels = structure.labels
    # Load Band Structure Calculations
    bands = Vasprun(args.vasprun_file_bands,parse_potcar_file=args.POTCAR_file).get_band_structure(args.KPOINTS_file, line_mode = True)
    # Read KPOINTS file with path
    kpts = Kpoints.from_file(args.KPOINTS_file)  

    # projected bands - get both spin up and spin down data
    procar = Procar(args.PROCAR_file)
    data_up = procar.data[Spin.up]
    data_down = procar.data[Spin.down] if Spin.down in procar.data else None
    
    # density of states
    dosrun = Vasprun(args.vasprun_file_dos,parse_potcar_file=args.POTCAR_file)

    # k-point labels
    n_labels = len(kpts.labels)
    labels = []
    labels.append(kpts.labels[0])
    for label_idx in range(1,n_labels,2):
        labels.append(kpts.labels[label_idx])
    
    # Number of points between kpoints, found in the KPOINTS file
    step = kpts.num_kpts


    # general options for plot
    font = {'family': 'serif', 'size': args.font_size}
    plt.rc('font', **font)

    # set up 2 graph with aspec ratio args.ratio/1
    # plot 1: bands diagram
    # plot 2: DOS
    gs = GridSpec(1, 2, width_ratios=[args.ratio,1], wspace=0.1)
    fig = plt.figure(figsize=(args.width, args.height))
    ax1 = plt.subplot(gs[0])
    ax2 = plt.subplot(gs[1]) #, sharey=ax1)

    # Set both fermi levels equal to the band fermi level
    bands.efermi =  dosrun.efermi #= 0

    # set y limits for the plot
    emin = args.emin
    emax = args.emax

    # if either is not defined
    if emin is None and emax is None:
        emin=100
        emax=-100
        for spin in bands.bands.keys():
            for b in range(bands.nb_bands):
                emin = min(emin, min(bands.bands[spin][b]))
                emax = max(emax, max(bands.bands[spin][b]))
    elif emin is None:
        emin=100
        for spin in bands.bands.keys():
            for b in range(bands.nb_bands):
                emin = min(emin, min(bands.bands[spin][b]))
    elif emax is None:
        emax=-100
        for spin in bands.bands.keys():
            for b in range(bands.nb_bands):
                emax = max(emax, max(bands.bands[spin][b]))
    
    ax1.set_ylim(emin, emax)
    ax2.set_ylim(emin, emax)

    # 检测是否需要绘制投影能带
    draw_projected_bands = True
    if args.element:
        print(f"Orbital bubble plot enabled for {args.element} {args.orbital_type}-orbitals")
        draw_projected_bands = False  # 当指定元素和轨道类型时，不绘制投影能带

    # accepts only 2 or 3 entries for the projection
    if len(args.project) != 2 and len(args.project) != 3 and draw_projected_bands:
        raise ValueError('Either 2 or 3 components for the projection')

    # 定义轨道类型
    orbital_values = { 
        's': 0, 
        'py': 1, 'pz': 2, 'px': 3, 
        'dxy': 4, 'dyz': 5, 'dz2': 6, 'dxz': 7, 'dx2_y2': 8, 
        'f_3' : 9, 'f_2' : 10, 'f_1' : 11, 'f0' : 12, 'f1' : 13, 'f2' : 14, 'f3' : 15 
    }
    
    # ===== 新增：自动检测所需的轨道类型 =====
    # 定义轨道名称到角动量l的映射
    orbital_to_l = {
        's': 0,
        'p': 1, 'px':1, 'py':1, 'pz':1,
        'd': 2, 'dxy':2, 'dyz':2, 'dz2':2, 'dxz':2, 'dx2_y2':2,
        'f': 3, 'f_3':3, 'f_2':3, 'f_1':3, 'f0':3, 'f1':3, 'f2':3, 'f3':3
    }

    # 保存原始的max_l
    original_max_l = args.max_l

    # 如果用户没有指定--max-l（即使用默认值1），则检查投影参数
    if original_max_l == 1:  # 默认值
        max_required_l = 1
        for component in args.project:
            # 分割投影字符串
            element_components = component.split("+")
            for element_component in element_components:
                splits = element_component.split(".")
                if len(splits) > 1:
                    orbitals = splits[1:]
                    for orb in orbitals:
                        # 如果轨道在映射中，则获取l值
                        if orb in orbital_to_l:
                            l_val = orbital_to_l[orb]
                            if l_val > max_required_l:
                                max_required_l = l_val
        # 更新max_l
        args.max_l = max_required_l

    # 如果max_l被调整了，记录日志
    if original_max_l != args.max_l:
        logging.info(f"Automatically adjusted max_l from {original_max_l} to {args.max_l} based on projection")
        print(f"Automatically adjusted max_l from {original_max_l} to {args.max_l} based on projection")
    # ===== 新增结束 =====

    max_l_index = (args.max_l + 1)**2   # 1 -> 4, 2 -> 9, 3 -> 16. So to have range(0,max_l_index) = [0,1,...,max_l_index-1]
    
    # 定义p轨道
    p_orbitals = ['px', 'py', 'pz']
    p_orbital_indices = [orbital_values[o] for o in p_orbitals]
    
    # 定义d轨道
    d_orbitals = ['dxy', 'dyz', 'dz2', 'dxz', 'dx2_y2']
    d_orbital_indices = [orbital_values[o] for o in d_orbitals]
    
    # 定义轨道的形状和颜色（空心）
    orbital_markers = {
        'dxy': ('s', 'black'),      # 黑色正方形（空心）
        'dxz': ('o', 'red'),        # 红色圆形（空心）
        'dyz': ('^', 'green'),      # 绿色正三角形（空心）
        'dz2': ('v', 'blue'),       # 蓝色倒三角形（空心）
        'dx2_y2': ('D', 'cyan'),    # 天蓝色菱形（空心）
        'px': ('o', 'red'),         # 红色圆形（空心）
        'py': ('s', 'green'),       # 绿色正方形（空心）
        'pz': ('^', 'blue')         # 蓝色正三角形（空心）
    }

    # 根据轨道类型选择要绘制的轨道
    if args.orbital_type == 'd':
        orbitals_to_plot = d_orbitals
        orbital_indices = d_orbital_indices
    elif args.orbital_type == 'p':
        orbitals_to_plot = p_orbitals
        orbital_indices = p_orbital_indices
    else:
        orbitals_to_plot = []
        orbital_indices = []

    # 只有当需要绘制投影能带时才计算投影贡献
    if draw_projected_bands:
        # calculates contributions for bands and DOS projections
        el_orbs = []
        el_orbs_labels = []
        for component in args.project:         # either 2 or 3 components, e.g. 'N.s.pz', 'N.s+O.s.pz', 'N.s', 'N+O', 'X', 'X.s', 'X.s+N.px.py.pz', ...
            element_components = component.split("+")   # split elements, e.g. 'N.s+O.s.pz' becomes ['N.s', 'O.s.pz']
            color_component = []
            label_text = []
            for element_component in element_components:
                splits = element_component.split(".")     # e.g. 'N.s.pz' converted to ['N', 's', 'pz']
                element = splits[0]                       # first element is the atom symbol
                if len(splits) == 1:                    # if no orbital is specified (e.g. 'N'), then plot all orbitals (= 'all')
                    orbitals = 'all'
                else:
                    orbitals = splits[1:]               # e.g. ['s', 'pz'] 
                color_component.append([element,orbitals])

                # write text for legend
                if element == 'X':                      # 'X' represents all atoms
                    if len(splits) == 1:
                        label_text.append('s+p_x+p_y+p_z')       # this makes no sense, it's the projection of all atoms and orbitals, put who am I to judge
                    else:
                        label_text.append("+".join(orbitals).replace('p','p_'))   # e.g. 'X.s.pz' becomes 's+p_z'
                else:
                    if len(splits) == 1:                     # all orbitals, only the element: 'N'
                        label_text.append(element)
                    else:
                        label_text.append(f"{element}({','.join(orbitals).replace('p','p_')})")   # e.g. 'O.s.pz' becomes 'O(s+p_z)'
            el_orbs.append(color_component)
            el_orbs_labels.append("+".join(label_text))           # e.g. 'O.s.pz+H.s' becomes 'O(s+p_z)+H(s)'


        color_values = { 0: 'red', 1: 'green', 2: 'blue' }        
        print('projections:')
        for color_idx, color_contrib in enumerate(el_orbs_labels):
            print(f'color {color_values[color_idx]}: {color_contrib}')

        # contributions to the band per each band, k-point, and color: contrib_bands[spin][band][k-point][color]
        contrib_bands = {
            Spin.up: np.zeros((bands.nb_bands, len(bands.kpoints), 3))
        }
        if data_down is not None:
            contrib_bands[Spin.down] = np.zeros((bands.nb_bands, len(bands.kpoints), 3))

        # 检测自旋极化DOS计算
        has_spin_down_dos = (Spin.down in dosrun.pdos[0][Orbital.s])  # 检测是否存在自旋向下分量

        # 初始化contrib_dos，分别存储自旋向上和自旋向下（如果存在）
        contrib_dos = {
            Spin.up: np.zeros((len(el_orbs), len(dosrun.tdos.energies))),
        }
        if has_spin_down_dos:
            contrib_dos[Spin.down] = np.zeros((len(el_orbs), len(dosrun.tdos.energies)))
        else:
            contrib_dos[Spin.down] = None

        # 添加进度条 - 计算投影贡献
        print("\nCalculating projections:")
        for spin in [Spin.up, Spin.down]:
            if spin not in contrib_bands:
                continue
                
            # 创建进度条
            spin_name = "up" if spin == Spin.up else "down"
            band_range = tqdm(range(bands.nb_bands), 
                              desc=f"Processing {spin_name} bands", 
                              total=bands.nb_bands,
                              leave=True)
            
            # sum over all bands
            for b in band_range:
                # sum over all k-points
                for k in range(len(bands.kpoints)):
                    for color_idx, color_contrib in enumerate(el_orbs): # color_idx: up to either 2 or 3. color_contrib: list of [elements, orbitals] for each color
                        for element_contrib in color_contrib:
                            element = element_contrib[0]     # e.g. 'X', 'N'
                            orbitals = element_contrib[1]        # e.g. 'all', 's', ['s', 'pz']
                            if element == 'X':                   # if all atoms, get all indexes
                                element_indexes = range(len(atom_labels))
                            else:                               # else, get the indexes with label = atom symbol (e.g. 'C')
                                element_indexes = [i for i, x in enumerate(atom_labels) if x == element]

                            if orbitals == 'all':
                                orbital_indexes = range(0,max_l_index)   # sum all orbitals if 'all'
                            else:
                                orbital_indexes = [orbital_values[o] for o in orbitals]
                                
                            for i in element_indexes:
                                for j in orbital_indexes:
                                    if spin == Spin.up:
                                        contrib_bands[spin][b,k,color_idx] += data_up[k][b][i][j]**2
                                    else:  # spin down
                                        contrib_bands[spin][b,k,color_idx] += data_down[k][b][i][j]**2
                                    
                                    # Only need to add to DOS once (using spin up)
                                    if spin == Spin.up and k == 0 and b == 0:
                                        contrib_dos[Spin.up][color_idx] += np.array(dosrun.pdos[i][Orbital(j)][Spin.up])
                                        if has_spin_down_dos:
                                            contrib_dos[Spin.down][color_idx] += np.array(dosrun.pdos[i][Orbital(j)][Spin.down])

                    # normalization
                    if args.normalization == 'selection':
                        if np.sum(contrib_bands[spin][b,k,:]) != 0:
                            contrib_bands[spin][b,k,:] = contrib_bands[spin][b,k,:]/np.sum(contrib_bands[spin][b,k,:])
                    elif args.normalization == 'all':
                        tot = 0.0
                        for i in range(len(atom_labels)):
                            for j in range(0,max_l_index):
                                if spin == Spin.up:
                                    tot += data_up[k][b][i][j]**2
                                else:
                                    tot += data_down[k][b][i][j]**2
                        if tot != 0:
                            contrib_bands[spin][b,k,:] = contrib_bands[spin][b,k,:]/tot   

    # 添加进度条 - 计算轨道权重
    weights = {}
    if args.element:
        print(f"\nCalculating {args.orbital_type}-orbital weights for {args.element}:")
        weights = {
            Spin.up: {orb: np.zeros((bands.nb_bands, len(bands.kpoints))) for orb in orbitals_to_plot},
            Spin.down: {orb: np.zeros((bands.nb_bands, len(bands.kpoints))) for orb in orbitals_to_plot}
        }
        
        # 获取特定元素的原子索引
        element_indexes = [i for i, x in enumerate(atom_labels) if x == args.element]
        if not element_indexes:
            raise ValueError(f"No atoms of element {args.element} found in the structure")
            
        for spin in [Spin.up, Spin.down]:
            if spin == Spin.down and data_down is None:
                continue
                
            # 创建进度条
            spin_name = "up" if spin == Spin.up else "down"
            band_range = tqdm(range(bands.nb_bands), 
                              desc=f"Processing {spin_name} weights", 
                              total=bands.nb_bands,
                              leave=True)
            
            for b in band_range:
                for k in range(len(bands.kpoints)):
                    # 计算该元素所有指定轨道的总贡献
                    total = 0.0
                    for i in element_indexes:
                        for j in orbital_indices:
                            if spin == Spin.up:
                                total += data_up[k][b][i][j]**2
                            else:
                                total += data_down[k][b][i][j]**2
                    
                    # 计算每个轨道的权重
                    for orb in orbitals_to_plot:
                        j = orbital_values[orb]
                        orb_value = 0.0
                        for i in element_indexes:
                            if spin == Spin.up:
                                orb_value += data_up[k][b][i][j]**2
                            else:
                                orb_value += data_down[k][b][i][j]**2
                        
                        if total > 1e-6:  # 避免除以零
                            weight = orb_value / total
                        else:
                            weight = 0.0
                        
                        weights[spin][orb][b, k] = weight

    reciprocal = bands.lattice_rec.matrix/(2*math.pi)

    # unchanged from Kevin Waters
    # Empty lists used for caculating the distances between K-Points
    KPOINTS = [0.0]
    DIST = 0.0
    # Create list with distances between Kpoints (Individual), corrects the spacing
    for k in range(len(bands.kpoints)-1 ):
        Dist = np.subtract(bands.kpoints[k+1].frac_coords,bands.kpoints[k].frac_coords)
        DIST += np.linalg.norm(np.dot(reciprocal,Dist))
        KPOINTS.append(DIST)

    # 只有当需要绘制投影能带时才绘制彩色能带
    if draw_projected_bands:
        print("Plotting projected bands...")
        for spin in [Spin.up, Spin.down]:
            if spin not in contrib_bands:
                continue
                
            for b in range(bands.nb_bands):
                rgbline(ax1,
                        range(len(bands.kpoints)),
                        [e - bands.efermi for e in bands.bands[spin][b]],
                        contrib_bands[spin][b,:,0],
                        contrib_bands[spin][b,:,1],
                        contrib_bands[spin][b,:,2] if len(args.project) == 3 else np.zeros(len(bands.kpoints)),     # 如果只有两个颜色，第三个分量设为零
                        KPOINTS=KPOINTS)
    else:
        # 绘制简单的能带图（灰色）
        print("Plotting simple bands...")
        for spin in [Spin.up, Spin.down]:
            if spin not in bands.bands:
                continue
                
            for b in range(bands.nb_bands):
                ax1.plot(KPOINTS, [e - bands.efermi for e in bands.bands[spin][b]], 
                         color='gray', alpha=0.5, linewidth=0.8)

    # 优化后的轨道气泡图绘制（空心气泡）
    if args.element:
        print(f"Plotting {args.orbital_type}-orbital bubbles...")
        # 计算气泡大小范围
        min_size = args.bubble_min * args.bubble_scale
        max_size = args.bubble_max * args.bubble_scale
        
        # 为每个轨道绘制气泡（空心）
        for spin in [Spin.up, Spin.down]:
            if spin not in weights:
                continue
                
            for orb in orbitals_to_plot:
                marker, color = orbital_markers[orb]
                # 收集所有点一次性绘制
                x_vals = []
                y_vals = []
                sizes = []
                
                # 使用步长减少点数
                k_step = args.bubble_density
                b_step = args.bubble_density
                
                # 创建进度条
                total_points = (bands.nb_bands // b_step) * (len(bands.kpoints) // k_step)
                if total_points > 0:
                    progress = tqdm(total=total_points,
                                    desc=f"{orb} bubbles",
                                    unit="point")
                else:
                    progress = None
                
                for b in range(0, bands.nb_bands, b_step):
                    for k in range(0, len(bands.kpoints), k_step):
                        weight = weights[spin][orb][b, k]
                        
                        # 只绘制权重大于阈值的点
                        if weight > args.bubble_threshold:
                            # 计算气泡大小（与权重成正比）
                            size = min_size + weight * (max_size - min_size)
                            
                            # 获取能量值
                            energy = bands.bands[spin][b][k] - bands.efermi
                            
                            # 添加点
                            x_vals.append(KPOINTS[k])
                            y_vals.append(energy)
                            sizes.append(size)
                            
                        if progress:
                            progress.update(1)
                
                # 一次性绘制该轨道的所有点（空心）
                if x_vals:  # 确保列表不为空
                    ax1.scatter(
                        x_vals, 
                        y_vals,
                        s=sizes,
                        marker=marker,
                        facecolors='none',  # 空心
                        edgecolors=color,   # 边框颜色
                        linewidths=0.4,     # 边框线宽
                        alpha=0.4,          # 稍微降低透明度
                        zorder=10           # 确保气泡在能带上方
                    )
                
                if progress:
                    progress.close()
        
        # 创建图例（只包含轨道气泡）
        legend_handles = []
        for orb in orbitals_to_plot:
            marker, color = orbital_markers[orb]
            legend_handles.append(
                plt.Line2D([0], [0], 
                            marker=marker, 
                            color=color, 
                            markerfacecolor='none',  # 空心
                            markeredgecolor=color,
                            markersize=8, 
                            linestyle='None',
                            label=f"{orb}")
            )
        
        # 在右侧的ax2上绘制图例（DOS位置）
        ax2.clear()  # 清除原有内容
        ax2.axis('off')  # 关闭坐标轴
        
        # 创建图例并放置在右侧中央位置
        ax2.legend(handles=legend_handles, 
               loc='center',  # 中心位置
               bbox_to_anchor=(0.57, 0.81),  # 精确中心位置
               fancybox=False, 
               shadow=False, 
               prop={'size': args.font_size},
               framealpha=0.8,
               title=f"{args.element} {args.orbital_type}-orbitals",
               title_fontsize=args.font_size)
        
        # 调整标题位置
        ax1.set_title(f"{args.element} {args.orbital_type}-orbitals", 
                     fontsize=args.font_size, pad=10,y=1.05)
        # 调整右侧子图位置，使图例更靠近能带图
        plt.subplots_adjust(right=0.85)  # 增加右侧空白区域

    # style
    ax1.set_ylabel(r"$E - E_f$ (eV)",labelpad=-2)     #labelpad might work bad
    ax1.grid()

    # fermi level line at 0
    ax1.hlines(y=0, xmin=0, xmax=len(bands.kpoints), color="k", lw=2)

    TICKS = [0.0]
    for i in range(step,len(KPOINTS)+step,step):
        ax1.vlines(KPOINTS[i-1], emin, emax, "k")
        TICKS.append(KPOINTS[i-1])
    ax1.set_xticks(TICKS)
    ax1.set_xticklabels(labels)
    ax1.tick_params(axis='x', which='both', length=0, pad=5)
    ax1.set_xlim(0, KPOINTS[-1])


    # 只有当需要绘制投影能带时才绘制DOS
    if draw_projected_bands:
        print("Plotting DOS...")
        # 绘制总DOS
        if has_spin_down_dos:
            # 自旋向上（正方向）
            ax2.plot(dosrun.tdos.densities[Spin.up], dosrun.tdos.energies - dosrun.efermi,
                     color=(0.6, 0.6, 0.6), label="total up", lw=1)
            # 自旋向下（负方向）
            ax2.plot(-dosrun.tdos.densities[Spin.down], dosrun.tdos.energies - dosrun.efermi,
                     color=(0.6, 0.6, 0.6), label="total down", lw=1)
            # 填充区域
            ax2.fill_betweenx(dosrun.tdos.energies - dosrun.efermi,
                             0, dosrun.tdos.densities[Spin.up],
                             color=(0.7, 0.7, 0.7), facecolor=(0.7, 0.7, 0.7))
            ax2.fill_betweenx(dosrun.tdos.energies - dosrun.efermi,
                             0, -dosrun.tdos.densities[Spin.down],
                             color=(0.7, 0.7, 0.7), facecolor=(0.7, 0.7, 0.7))
            # 计算最大DOS值（考虑两个自旋方向）
            maxdos = max(np.max(dosrun.tdos.densities[Spin.up]), 
                         np.max(dosrun.tdos.densities[Spin.down])) / scale
        else:
            # 非自旋极化计算
            ax2.plot(dosrun.tdos.densities[Spin.up], dosrun.tdos.energies - dosrun.efermi,
                     color=(0.6, 0.6, 0.6), label="total", lw=1)
            ax2.fill_betweenx(dosrun.tdos.energies - dosrun.efermi,
                             0, dosrun.tdos.densities[Spin.up],
                             color=(0.7, 0.7, 0.7), facecolor=(0.7, 0.7, 0.7))
            maxdos = np.max(dosrun.tdos.densities[Spin.up]) / scale

        # 绘制投影DOS（自旋向上）
        ax2.plot(contrib_dos[Spin.up][0], dosrun.tdos.energies - dosrun.efermi,
                 c=(1.0, 0.0, 0.0), label=f'${el_orbs_labels[0]}$', linewidth=1)
        ax2.plot(contrib_dos[Spin.up][1], dosrun.tdos.energies - dosrun.efermi,
                 c=(0.0, 1.0, 0.0), label=f'${el_orbs_labels[1]}$', linewidth=1)

        # 如果有自旋向下分量，绘制负方向的投影
        if has_spin_down_dos:
            ax2.plot(-contrib_dos[Spin.down][0], dosrun.tdos.energies - dosrun.efermi,
                     c=(1.0, 0.0, 0.0), linewidth=1)
            ax2.plot(-contrib_dos[Spin.down][1], dosrun.tdos.energies - dosrun.efermi,
                     c=(0.0, 1.0, 0.0), linewidth=1)

        # 如果有第三个颜色分量
        if len(el_orbs) == 3:
            ax2.plot(contrib_dos[Spin.up][2], dosrun.tdos.energies - dosrun.efermi,
                     c=(0.0, 0.0, 1.0), label=f'${el_orbs_labels[2]}$', linewidth=1)
            if has_spin_down_dos:
                ax2.plot(-contrib_dos[Spin.down][2], dosrun.tdos.energies - dosrun.efermi,
                         c=(0.0, 0.0, 1.0), linewidth=1)

        # 调整x轴范围
        if has_spin_down_dos:
            ax2.set_xlim(-maxdos, maxdos)
        else:
            ax2.set_xlim(0, maxdos)

        # 添加y=0的水平线
        ax2.hlines(y=0, xmin=ax2.get_xlim()[0], xmax=ax2.get_xlim()[1], color="k", lw=2)

        # 添加x=0的垂直线（仅当有自旋向下分量时）
        if has_spin_down_dos:
            ax2.vlines(x=0, ymin=emin, ymax=emax, color="k", lw=1, linestyle='--', alpha=0.5)

        ax2.set_yticklabels([])
        ax2.grid()
        ax2.set_xticks([])
        ax2.set_xlabel("DOS")
        ax2.legend(fancybox=False, shadow=False, prop={'size': args.font_size-1}, 
                   labelspacing=0.15, borderpad=0.20, handlelength=1.2, 
                   framealpha=0.6, loc='upper right')

    # Plotting 
    # -----------------
    print("Saving plot...")
    plt.savefig(f"{args.output_file}.{args.format}", format=args.format, bbox_inches='tight')
    print("Done!")
```