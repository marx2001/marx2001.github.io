---
layout: post
title: "pythTB的学习_1"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20251209-PythonTB
---


# <center>Recording​</center>


### 1. 介绍

PythTB是一款用于构建和分析紧束缚模型的Python库，专为现代拓扑能带论应用而设计。它提供了从模型设定到物理解释的高效路径，既适用于电子结构的学习，也可用于研究级别的计算。只需几行代码，您就
能定义晶格模型、构建紧束缚哈密顿量并计算电子性质。

PythTB提供一个从模型构建、计算分析到结果可视化的完整工作流，其六大核心功能模块如下：

模型构建：核心是TBModel类，用于定义和操作紧束缚哈密顿量，可设置在位能、跃迁项、自旋结构及参数依赖项。

态采样：通过Mesh类构建结构化的k空间和参数网格，并在网格上采样哈密顿量，将结果态（波函数）存储于WFArray对象中以供后续分析。

拓扑与量子几何计算：利用WFArray和TBModel的方法，计算一系列关键物理量，包括贝里相位/联络/曲率、陈数、轴子角、局域陈数标记、混合万尼尔函数及其他量子几何观测量。

Wannier90集成：通过W90类导入Wannier90软件生成的紧束缚哈密顿量，以便进行后处理及拓扑/量子几何分析。

万尼尔函数工作流：使用Wannier类从WFArray构造最大局域化万尼尔函数，可执行投影、解纠缠、评估展宽，并分析其中心与局域化性质。

可视化：利用内置工具绘制能带结构、态密度、晶格几何、跃迁图及交互式3D模型。

总结而言，PythTB是一个功能集成的计算平台，它不仅能便捷地构建和分析各类紧束缚模型，其突出特色在于深度集成了万尼尔函数构造与高阶拓扑/量子几何量计算的能力，并提供了从数据计算到图形呈现的完整分析链条。

### 2. 从pythTB开始

安装后，激活环境：
```shell

conda activate pythtb_env

```

剩余步骤参考官网：https://pythtb.readthedocs.io/en/latest/install.html

### 3. New to v2.0

在2.0.0版本中，我们引入了Lattice类，用以封装晶格几何的所有信息，包括晶格矢量、轨道位置和周期性。通过这种模块化设计，实现了关注点的分离：Lattice类负责处理几何细节，而TBModel类则专注于紧束缚模型本身。这一设计显著提升了代码的可读性、可维护性和可复用性。

```python

from pythtb import Lattice
import numpy as np

```
以下代码片段演示了如何使用Lattice类定义晶格并构建紧束缚模型。以蜂窝晶格（每个原胞含两个轨道）为例，首先给出晶格矢量：

<img src="/img/pythTB的学习_1/bg-c1.png" style="width:25%; margin: 0 auto 5px auto; display: block;">


为简化计算，取晶格常数a=1。轨道位置用约化坐标表示为：

<img src="/img/pythTB的学习_1/bg-c2.png" style="width:25%; margin: 0 auto 5px auto; display: block;">

此设定对应类似石墨烯的结构。通过Lattice类封装晶格几何信息，可实现晶格定义与模型构建的分离，提升代码的清晰度和可维护性。

```python

lat_vecs = [[1, 0], [1 / 2, np.sqrt(3) / 2]]
orb_vecs = [[1 / 3, 1 / 3], [2 / 3, 2 / 3]]

```

我们将上述信息传入类中以创建一个晶格对象。此外，我们还需指定哪些方向具有周期性。在本示例中，两个方向均被设为周期性。

```python

lat = Lattice(orb_vecs=orb_vecs, lat_vecs=lat_vecs, periodic_dirs=[0, 1])

```

我们可以通过打印晶格对象，查看其生成的报告，以验证其中封装的晶格属性是否与预期一致。

```python

----------------------------------------
       Lattice structure report         
----------------------------------------
r-space dimension           = 2
k-space dimension           = 2
periodic directions         = [0, 1]
number of orbitals          = 2

Lattice vectors (Cartesian):
  # 0 ===> [ 1.000,  0.000]
  # 1 ===> [ 0.500,  0.866]
Volume of unit cell (Cartesian) = 0.866 [A^d]

Reciprocal lattice vectors (Cartesian):
  # 0 ===> [ 6.283, -3.628]
  # 1 ===> [ 0.000,  7.255]
Volume of reciprocal unit cell = 45.586 [A^-d]

Orbital vectors (Cartesian):
  # 0 ===> [ 0.500,  0.289]
  # 1 ===> [ 1.000,  0.577]

Orbital vectors (fractional):
  # 0 ===> [ 0.333,  0.333]
  # 1 ===> [ 0.667,  0.667]
----------------------------------------

```
如果我们想获取轨道在笛卡尔坐标系中的位置，可以使用 Lattice类的 get_orb_vecs方法，并将其参数 cartesian设置为 True。
```python

lat.get_orb_vecs(cartesian=True)

```
```python

array([[0.5       , 0.28867513],
       [1.        , 0.57735027]])

```
该类内部会根据提供的晶格矢量和周期性生成倒格矢。我们可以通过 Lattice类的方法 get_recip_lat_vecs或属性 recip_lat_vecs来访问这些倒格矢。

```python

print(lat.get_recip_lat_vecs())
print(lat.recip_lat_vecs)

```
```python

[[ 6.28318531 -3.62759873]
 [ 0.          7.25519746]]
[[ 6.28318531 -3.62759873]
 [ 0.          7.25519746]]

```

让我们验证倒格矢是否满足与实空间晶格矢量的正交性条件。

<img src="/img/pythTB的学习_1/bg-c3.png" style="width:25%; margin: 0 auto 5px auto; display: block;">

```python

overlap_mat = lat.lat_vecs @ lat.recip_lat_vecs.T
print(overlap_mat / (2 * np.pi))

```

```python

[[ 1.00000000e+00  0.00000000e+00]
 [-4.79476621e-17  1.00000000e+00]]

```

如果需要，我们也可以获取实空间和倒空间中的原胞体积，这些值存储在 Lattice类的相应属性中。

```python

print(lat.recip_volume, lat.cell_volume)

```
```python

45.58575006211245 0.8660254037844386

```