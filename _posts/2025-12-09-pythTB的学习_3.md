---
layout: post
title: "pythTB的学习_tb_model to TBModel in v2.0"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20251209-PythonTB_tb
---


# <center>Tutorials​</center>

在 TBModel 类的 v2.0 版本中，模块名称已发生重要变更。v1.8 版本中的 tb_model、wf_array和 w90在 v2.0 版本中已分别更新为 TBModel、WFArray​ 和 W90。在使用时，请注意在代码的导入行中相应
修改模块名称。
```python

from pythtb import TBModel, Lattice
import numpy as np
```

### 构建一个TB模型
在 v2.0 版本中，模型的构建方式发生了变化。我们不再将晶格矢量和轨道位置作为单独的参数传递，而是传递一个包含这些信息的 Lattice对象。

我们将以蜂窝晶格为例进行说明。在 v1.8 版本中，我们会这样操作：

```python

# v1.8 code
from pythtb import tb_model 

lat_vecs = [[1, 0], [1/2, np.sqrt(3) / 2]]
orb_vecs = [[1/3, 1/3], [2/3, 2/3]]
model = tb_model(dim_r = 2, dim_k = 2, lat=lat_vecs, orb=orb_vecs, per=[0,1], nspin=1)

```


在 v2.0 版本中，我们首先创建一个 Lattice对象，然后将其传递给 TBModel构造器。

需要注意的几个行为变化如下：

为提高清晰度，per参数已更名为 periodic_dirs。若未指定，v1.8 版本的默认行为是假设所有方向均为周期性的；而在 v2.0 中，默认设置为无周期性方向。

整数参数 nspin已被替换为布尔型参数 spinful，用于指示模型是否具有自旋自由度。

dim_r和 dim_k不再是必需参数，因为它们可以从 lat_vecs和 periodic_dirs中推断得出。

其余大部分功能基本保持不变，仅被封装在 Lattice对象中。


####提示​:

将所有晶格方向指定为周期性的便捷方法是为 periodic_dirs参数使用 ...，例如 periodic_dirs=...。此外，也可以通过传递 periodic_dirs="all"来实现相同效果。

以下是 v2.0 中对应的代码：

```python

lat_vecs = [[1, 0], [1 / 2, np.sqrt(3) / 2]]
orb_vecs = [[1 / 3, 1 / 3], [2 / 3, 2 / 3]]
lat = Lattice(lat_vecs=lat_vecs, orb_vecs=orb_vecs, periodic_dirs=[0, 1])
model = TBModel(lattice=lat, spinful=False)

```

```python

delta = 0
t1 = -1
t2 = 0.15
phi = np.pi / 2

model.set_onsite([-delta, delta], mode="set")

for lvec in ([0, 0], [-1, 0], [0, -1]):
    model.set_hop(t1, 0, 1, lvec, mode="set")

for lvec in ([1, 0], [-1, 1], [0, -1]):
    model.set_hop(t2 * np.exp(1j * phi), 0, 0, lvec, mode="set")
for lvec in ([-1, 0], [1, -1], [0, 1]):
    model.set_hop(t2 * np.exp(1j * phi), 1, 1, lvec, mode="set")

```

### 模型库

一系列用于原型紧束缚模型的 TBModel 生成器已被收录在 pythtb.models中。这些模型包括：

棋盘模型

霍尔丹模型

凯恩-梅莱模型

石墨烯模型

举个例子，我们可以从模型库中导入与上文相同的霍尔丹紧束缚模型：

```python

from pythtb.models import haldane

my_model = haldane(delta=0.1, t1=1.0, t2=0.1)

```

### 报告模型信息

使用下面代码查看模型信息：

```python

# v1.8
my_model.display()

# v2.0
print(my_model)
# or
my_model.info()
```

```python

print(my_model)

```

结果：

```python

----------------------------------------
       Tight-binding model report       
----------------------------------------
r-space dimension           = 2
k-space dimension           = 2
periodic directions         = [0, 1]
spinful                     = False
number of spin components   = 1
number of electronic states = 2
number of orbitals          = 2

Lattice vectors (Cartesian):
  # 0 ===> [ 1.000,  0.000]
  # 1 ===> [ 0.500,  0.866]
Volume of unit cell (Cartesian) = 0.866 [A^d]

Reciprocal lattice vectors (Cartesian):
  # 0 ===> [ 6.283, -3.628]
  # 1 ===> [ 0.000,  7.255]
Volume of reciprocal unit cell = 45.586 [A^-d]

Orbital vectors (Cartesian):
  # 0 ===> [ 0.500,  0.289]
  # 1 ===> [ 1.000,  0.577]

Orbital vectors (fractional):
  # 0 ===> [ 0.333,  0.333]
  # 1 ===> [ 0.667,  0.667]
----------------------------------------
Site energies:
  < 0 | H | 0 > = -0.100 
  < 1 | H | 1 > =  0.100 
Hoppings:
  < 0 | H | 1  + [ 0.0 ,  0.0 ] > = 1.0000+0.0000j
  < 0 | H | 1  + [-1.0 ,  0.0 ] > = 1.0000+0.0000j
  < 0 | H | 1  + [ 0.0 , -1.0 ] > = 1.0000+0.0000j
  < 0 | H | 0  + [ 1.0 ,  0.0 ] > = 0.0000+0.1000j
  < 0 | H | 0  + [-1.0 ,  1.0 ] > = 0.0000+0.1000j
  < 0 | H | 0  + [ 0.0 , -1.0 ] > = 0.0000+0.1000j
  < 1 | H | 1  + [-1.0 ,  0.0 ] > = 0.0000+0.1000j
  < 1 | H | 1  + [ 1.0 , -1.0 ] > = 0.0000+0.1000j
  < 1 | H | 1  + [ 0.0 ,  1.0 ] > = 0.0000+0.1000j
Hopping distances:
  | pos( 0 ) - pos( 1 ) + [ 0.0 ,  0.0 ] | =   0.577
  | pos( 0 ) - pos( 1 ) + [-1.0 ,  0.0 ] | =   0.577
  | pos( 0 ) - pos( 1 ) + [ 0.0 , -1.0 ] | =   0.577
  | pos( 0 ) - pos( 0 ) + [ 1.0 ,  0.0 ] | =   1.000
  | pos( 0 ) - pos( 0 ) + [-1.0 ,  1.0 ] | =   1.000
  | pos( 0 ) - pos( 0 ) + [ 0.0 , -1.0 ] | =   1.000
  | pos( 1 ) - pos( 1 ) + [-1.0 ,  0.0 ] | =   1.000
  | pos( 1 ) - pos( 1 ) + [ 1.0 , -1.0 ] | =   1.000
  | pos( 1 ) - pos( 1 ) + [ 0.0 ,  1.0 ] | =   1.000

```

### 紧束缚模型的可视化

紧束缚模型（TB）的轨道位置与跃迁键的可视化功能已更新。

与之前一样，我们调用 my_model.visualize来查看紧束缚晶格。

在 v1.8 版本中，应使用如下方式：

```python

# v1.8
my_model.visualize(0, 1)

```

结果图为：
<img src="/img/pythTB的学习_1/bg-c4.png" style="width:25%; margin: 0 auto 5px auto; display: block;">

区别在于，在绘制二维图形时，我们不再需要指定晶格方向。对于三维模型，仍可通过 proj_plane参数指定两个对应于ai和aj晶格矢量的整数，以将三维结构投影到该平面上。默认行为是：二维模型直接绘制二
维图形，三维模型默认投影到 a1-a2平面上。..note:: 对于三维模型，如果安装了 plotly，现在可以使用 visualize3d()绘制三维结构。

在 v2.0 版本中，输出效果如下所示：

<img src="/img/pythTB的学习_1/bg-c5.png" style="width:25%; margin: 0 auto 5px auto; display: block;">

请注意，图中键的粗细并非完全一致。其透明度（alpha 值）会根据跃迁强度进行比例缩放。此外，我们现在还可以通过设置 annotate_onsite_en参数为 True来标注每个格点的位能值。

### 获得哈密顿量矩阵

在pythtb的旧版本中，用户无法直接获取哈密顿矩阵。相反，需要通过调用my_model.solve_all(kpts)或my_model.solve_one(kpt)函数来获取给定k点的本征值和本征向量。而在v2.0版本中，新增了
my_model.hamiltonian(kpts)方法，允许用户直接获取一系列k点上的哈密顿矩阵，该方法会返回一个NumPy数组。

```python

# Generate k-points
nkx, nky = 20, 20
k_pts = my_model.k_uniform_mesh([nkx, nky])

```

```python

H_k = my_model.hamiltonian(k_pts)

print("Hamiltonian shape:", H_k.shape)
print("Hamiltonian at first k-point:\n", H_k[0])
print("Hamiltonian at second k-point:\n", H_k[1])

```

```python 

Hamiltonian shape: (400, 2, 2)
Hamiltonian at first k-point:
 [[-0.1+0.j  3. +0.j]
 [ 3. +0.j  0.1+0.j]]
Hamiltonian at second k-point:
 [[-0.1       +0.j          2.96365774+0.00133535j]
 [ 2.96365774-0.00133535j  0.1       +0.j        ]]

```


### 能带绘制

TBModel 的一个新功能是增加了一个便捷函数，可快速绘制能带结构。我们不再需要显式创建 k 路径和 matplotlib 图形，只需调用 plot_bands 并传递以约化单位表示的高对称点即可。这将返回 matplotlib 图形和坐标轴对象，以供进一步自定义。

注意

我们还可以传递 k_node_labels 参数来指定高对称点的标签。

```python

# v1.8 code
path=[[0.,0.],[2./3.,1./3.],[.5,.5],[1./3.,2./3.], [0.,0.]]
label=(r'$\Gamma $',r'$K$', r'$M$', r'$K^\prime$', r'$\Gamma $')

(k_vec,k_dist,k_node) = my_model.k_path(path,101)
evals = my_model.solve_all(k_vec)

fig, ax = plt.subplots()
ax.set_xlim(k_node[0],k_node[-1])
ax.set_xticks(k_node)
ax.set_xticklabels(label)
for n in range(len(k_node)):
  ax.axvline(x=k_node[n],linewidth=0.5, color='k')
ax.set_ylabel("Band energy")

ax.plot(k_dist,evals[0])
ax.plot(k_dist,evals[1])

```

```python

k_nodes = [[0, 0], [2 / 3, 1 / 3], [0.5, 0.5], [1 / 3, 2 / 3], [0, 0], [0.5, 0.5]]
k_label = (r"$\Gamma $", r"$K$", r"$M$", r"$K^\prime$", r"$\Gamma $", r"$M$")

fig, ax = my_model.plot_bands(k_nodes=k_nodes, k_node_labels=k_label)

```

一个可选参数允许用户可视化能带的轨道特征。为此，我们向 proj_orb_idx参数提供一个列表。该列表定义了用于本征态投影的轨道索引。系统将显示一个颜色条，展示本征态在这些轨道集合上的权重。

在本示例中，Haldane 模型在 K 点和 K' 点处展示了能带反转现象，这正是拓扑相变的典型特征。

```python

fig, ax = my_model.plot_bands(
    nk=500, k_nodes=k_nodes, k_node_labels=k_label, proj_orb_idx=[1]
)

```

<img src="/img/pythTB的学习_1/bg-c6.png" style="width:25%; margin: 0 auto 5px auto; display: block;">

### 向后兼容性


为保持与为 PythTB v1.8 及更早版本编写的脚本的向后兼容性，旧版 tb_model仍可作为 TBModel的别名使用。其函数与方法将采用 v2.0 版本的实现，但初始化 tb_model类的旧方式依然有效。

```python

from pythtb import tb_model
import numpy as np

```
从V1.8.0的Haldane model initialization:

```python

# define lattice vectors
lat = [[1.0, 0.0], [0.5, np.sqrt(3.0) / 2.0]]
# define coordinates of orbitals
orb = [[1.0 / 3.0, 1.0 / 3.0], [2.0 / 3.0, 2.0 / 3.0]]

# make two dimensional tight-binding Haldane model
my_model = tb_model(2, 2, lat, orb)

# set model parameters
delta = 0.2
t = -1.0
t2 = 0.15 * np.exp((1.0j) * np.pi / 2.0)
t2c = t2.conjugate()

# set on-site energies
my_model.set_onsite([-delta, delta])
# set hoppings (one for each connected pair of orbitals)
# (amplitude, i, j, [lattice vector to cell containing j])
my_model.set_hop(t, 0, 1, [0, 0])
my_model.set_hop(t, 1, 0, [1, 0])
my_model.set_hop(t, 1, 0, [0, 1])
# add second neighbour complex hoppings
my_model.set_hop(t2, 0, 0, [1, 0])
my_model.set_hop(t2, 1, 1, [1, -1])
my_model.set_hop(t2, 1, 1, [0, 1])
my_model.set_hop(t2c, 1, 1, [1, 0])
my_model.set_hop(t2c, 0, 0, [1, -1])
my_model.set_hop(t2c, 0, 0, [0, 1])

# print tight-binding model
my_model.display()

```

```python

----------------------------------------
       Tight-binding model report       
----------------------------------------
r-space dimension           = 2
k-space dimension           = 2
periodic directions         = [0, 1]
spinful                     = False
number of spin components   = 1
number of electronic states = 2
number of orbitals          = 2

Lattice vectors (Cartesian):
  # 0 ===> [ 1.000,  0.000]
  # 1 ===> [ 0.500,  0.866]
Volume of unit cell (Cartesian) = 0.866 [A^d]

Reciprocal lattice vectors (Cartesian):
  # 0 ===> [ 6.283, -3.628]
  # 1 ===> [ 0.000,  7.255]
Volume of reciprocal unit cell = 45.586 [A^-d]

Orbital vectors (Cartesian):
  # 0 ===> [ 0.500,  0.289]
  # 1 ===> [ 1.000,  0.577]

Orbital vectors (fractional):
  # 0 ===> [ 0.333,  0.333]
  # 1 ===> [ 0.667,  0.667]
----------------------------------------
Site energies:
  < 0 | H | 0 > = -0.200 
  < 1 | H | 1 > =  0.200 
Hoppings:
  < 0 | H | 1  + [ 0.0 ,  0.0 ] > = -1.0000+0.0000j
  < 1 | H | 0  + [ 1.0 ,  0.0 ] > = -1.0000+0.0000j
  < 1 | H | 0  + [ 0.0 ,  1.0 ] > = -1.0000+0.0000j
  < 0 | H | 0  + [ 1.0 ,  0.0 ] > = 0.0000+0.1500j
  < 1 | H | 1  + [ 1.0 , -1.0 ] > = 0.0000+0.1500j
  < 1 | H | 1  + [ 0.0 ,  1.0 ] > = 0.0000+0.1500j
  < 1 | H | 1  + [ 1.0 ,  0.0 ] > = 0.0000-0.1500j
  < 0 | H | 0  + [ 1.0 , -1.0 ] > = 0.0000-0.1500j
  < 0 | H | 0  + [ 0.0 ,  1.0 ] > = 0.0000-0.1500j
Hopping distances:
  | pos( 0 ) - pos( 1 ) + [ 0.0 ,  0.0 ] | =   0.577
  | pos( 1 ) - pos( 0 ) + [ 1.0 ,  0.0 ] | =   0.577
  | pos( 1 ) - pos( 0 ) + [ 0.0 ,  1.0 ] | =   0.577
  | pos( 0 ) - pos( 0 ) + [ 1.0 ,  0.0 ] | =   1.000
  | pos( 1 ) - pos( 1 ) + [ 1.0 , -1.0 ] | =   1.000
  | pos( 1 ) - pos( 1 ) + [ 0.0 ,  1.0 ] | =   1.000
  | pos( 1 ) - pos( 1 ) + [ 1.0 ,  0.0 ] | =   1.000
  | pos( 0 ) - pos( 0 ) + [ 1.0 , -1.0 ] | =   1.000
  | pos( 0 ) - pos( 0 ) + [ 0.0 ,  1.0 ] | =   1.000

```

```python

/tmp/ipykernel_1286/2945160337.py:7: DeprecationWarning: pythtb.tb_model is deprecated and will be removed in a future release. Use TBModel instead.
  my_model = tb_model(2, 2, lat, orb)
/tmp/ipykernel_1286/2945160337.py:31: FutureWarning: TBModel.display is deprecated and will be removed in a future release: The 'display()' method is deprecated and will be removed in a future release. Use 'print(model)' or 'model.info(show=True)' instead.
  my_model.display()

```