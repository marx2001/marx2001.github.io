---
layout: post
title: "绘制精美的投影能带图"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20260205-fatband
---

## <center>说明</center>

用于记录写脚本的有用的版本，有些暂时用不上，但是绘制n重简并的能带的时候可以用到，还有的脚本的功能是任意数量的轨道组合也能画图，同时指定颜色，这两种脚本只选一种来使用，未免有些
可惜，所以都记录在此，后面根据论文排版不同，选择不同版本的脚本进行绘图。


## <center>脚本1</center>



绘制d轨道简并状态下的投影能带图，最少要设置3个轨道，后面有需要再改。

```python

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import re
import argparse
from typing import List, Tuple, Optional

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D


# =========================
# POSCAR
# =========================
def read_poscar_elements_counts(poscar_path: str) -> Tuple[List[str], List[int]]:
    with open(poscar_path, "r", encoding="utf-8", errors="ignore") as f:
        lines = [ln.strip() for ln in f.readlines() if ln.strip()]
    if len(lines) < 8:
        raise RuntimeError(f"POSCAR too short: {poscar_path}")
    elements = lines[5].split()
    counts = [int(x) for x in lines[6].split()]
    return elements, counts


def element_to_atom_indices_1based(elements: List[str], counts: List[int], pick: Optional[List[str]]) -> np.ndarray:
    total = sum(counts)
    if not pick:
        return np.arange(1, total + 1, dtype=int)

    pick_set = set(pick)
    out = []
    s = 1
    for el, n in zip(elements, counts):
        if el in pick_set:
            out.extend(range(s, s + n))
        s += n
    if not out:
        raise RuntimeError(f"Selected elements {pick} not found in POSCAR elements={elements}")
    return np.array(out, dtype=int)


# =========================
# OUTCAR: E-fermi
# =========================
def read_fermi_from_outcar(outcar_path: str) -> Optional[float]:
    if not os.path.exists(outcar_path):
        return None
    pat = re.compile(r"E-fermi\s*:\s*([-\d\.]+)")
    fermi = None
    with open(outcar_path, "r", encoding="utf-8", errors="ignore") as f:
        for ln in f:
            m = pat.search(ln)
            if m:
                fermi = float(m.group(1))
    return fermi


# =========================
# KPOINTS (VASPKIT)
# =========================
def pretty_label(lbl: str) -> str:
    s = lbl.strip()
    if s.upper() == "GAMMA":
        return r"$\Gamma$"
    if s in ("K'", "K’", "Kp", "KP"):
        return r"$K'$"
    return rf"${s}$"


def parse_vaskit_kpoints_nodes(kpoints_path: str) -> List[str]:
    coord_pat = re.compile(
        r"^\s*([-\d\.]+)\s+([-\d\.]+)\s+([-\d\.]+)\s+([A-Za-z0-9\-\+'’]+)\s*$"
    )
    labels_all = []
    with open(kpoints_path, "r", encoding="utf-8", errors="ignore") as f:
        for ln in f:
            m = coord_pat.match(ln.strip())
            if m:
                labels_all.append(m.group(4).strip())

    if len(labels_all) < 2:
        raise RuntimeError("Failed to parse high-symmetry labels from KPOINTS.")

    compressed = []
    for lab in labels_all:
        if not compressed or lab != compressed[-1]:
            compressed.append(lab)

    cleaned = []
    i = 0
    while i < len(compressed):
        cleaned.append(compressed[i])
        if i + 2 < len(compressed) and compressed[i + 1] == compressed[i + 2]:
            i += 2
        else:
            i += 1
    return cleaned


def make_kticks_knames(nodes: List[str], nk: int) -> Tuple[List[str], List[int]]:
    nseg = len(nodes) - 1
    kticks = [int(round(i * (nk - 1) / nseg)) for i in range(len(nodes))]
    kticks[0] = 0
    kticks[-1] = nk - 1
    knames = [pretty_label(x) for x in nodes]
    return knames, kticks


# =========================
# Orbitals mapping (PROCAR lm decomposed header order)
# ion s py pz px dxy dyz dz2 dxz x2-y2 tot
# =========================
ORBITAL_INDEX = {
    "s": 0,
    "py": 1, "pz": 2, "px": 3,
    "dxy": 4, "dyz": 5, "dz2": 6, "dxz": 7, "x2-y2": 8,
}
def normalize_orb(s: str) -> str:
    t = s.strip().lower().replace(" ", "").replace("^", "").replace("_", "")
    if t in ("dx2-y2", "dx2y2", "x2y2", "x2-y2"):
        return "x2-y2"
    return t


# =========================
# Robust PROCAR parser: auto-detect nspin even without "spin component"
# =========================
def parse_procar_lm_decomposed_autospin(procar_path: str, force_nspin: Optional[int] = None):
    """
    Returns:
      kpoints: (nk,3)
      energies: (nk, nb, nspin)
      weights:  (nk, nb, nion, 9, nspin)
      nk, nb, nion, nspin
    Works for:
      - with 'spin component 1/2'
      - without 'spin component', but PROCAR contains two full k-point cycles (k=1..nk) -> nspin=2
    """
    with open(procar_path, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    header_text = "".join(lines[:50])
    m = re.search(r"#\s*of\s*k-points:\s*([0-9]+)\s*#\s*of\s*bands:\s*([0-9]+)\s*#\s*of\s*ions:\s*([0-9]+)",
                  "".join(lines))
    if not m:
        raise RuntimeError("Failed to parse PROCAR header '# of k-points/bands/ions'.")

    nk = int(m.group(1)); nb = int(m.group(2)); nion = int(m.group(3))
    norb = 9

    # detect number of cycles of "k-point 1"
    kpt1_pat = re.compile(r"^\s*k-point\s+1\s*:", re.IGNORECASE)
    kpt1_count = sum(1 for ln in lines if kpt1_pat.match(ln))

    # prefer force if user specifies
    if force_nspin is not None:
        nspin = int(force_nspin)
    else:
        # typical: 1 cycle -> 1 spin; 2 cycles -> 2 spins
        nspin = 2 if kpt1_count >= 2 else 1

    # allocate arrays
    kpoints = np.zeros((nk, 3), dtype=float)
    energies = np.full((nk, nb, nspin), np.nan, dtype=float)
    weights  = np.zeros((nk, nb, nion, norb, nspin), dtype=float)

    # regex
    spin_pat = re.compile(r"spin\s+component\s+([12])", re.IGNORECASE)
    kpt_pat  = re.compile(r"^\s*k-point\s+(\d+)\s*:\s*([-\d\.Ee+]+)\s+([-\d\.Ee+]+)\s+([-\d\.Ee+]+)")
    band_pat = re.compile(r"^\s*band\s+(\d+)\s*#\s*energy\s+([-\d\.Ee+]+)")
    ion_header_pat = re.compile(r"^\s*ion\s+s\s+py\s+pz\s+px\s+dxy\s+dyz\s+dz2\s+dxz\s+x2-y2\s+tot", re.IGNORECASE)

    cur_spin = 0
    cur_k = -1
    cur_b = -1

    # For "no spin component" case, we auto-switch spin when k-point index resets
    seen_k_cycle = 0  # 0 for first cycle, 1 for second
    last_k_index = None

    i = 0
    while i < len(lines):
        ln = lines[i]

        # explicit spin tags (if present)
        ms = spin_pat.search(ln)
        if ms:
            cur_spin = int(ms.group(1)) - 1
            i += 1
            continue

        mk = kpt_pat.match(ln)
        if mk:
            k_index_1b = int(mk.group(1))  # 1..nk

            # auto spin switching if no explicit spin tags:
            if force_nspin is None and ("spin component" not in header_text.lower()):
                if last_k_index is not None and k_index_1b == 1 and last_k_index != 1:
                    # new cycle begins
                    seen_k_cycle += 1
                cur_spin = min(seen_k_cycle, nspin - 1)

            last_k_index = k_index_1b
            cur_k = k_index_1b - 1
            if cur_spin == 0:
                # only need store kpoints once
                kpoints[cur_k, :] = [float(mk.group(2)), float(mk.group(3)), float(mk.group(4))]
            i += 1
            continue

        mb = band_pat.match(ln)
        if mb:
            cur_b = int(mb.group(1)) - 1
            energies[cur_k, cur_b, cur_spin] = float(mb.group(2))
            i += 1
            continue

        if ion_header_pat.match(ln):
            # read nion rows next
            for j in range(nion):
                row = lines[i + 1 + j].split()
                ion_id = int(row[0]) - 1
                vals = [float(x) for x in row[1:1+norb]]
                weights[cur_k, cur_b, ion_id, :, cur_spin] = vals
            # skip: header + nion lines + "tot" line
            i = i + 1 + nion + 1
            continue

        i += 1

    # sanity
    if np.isnan(energies).any():
        nan_pos = np.argwhere(np.isnan(energies))
        raise RuntimeError(f"PROCAR parse incomplete: energies has NaNs, e.g. {nan_pos[:8].tolist()}")

    return kpoints, energies, weights, nk, nb, nion, nspin, kpt1_count


# =========================
# Main plotting
# =========================
def main():
    ap = argparse.ArgumentParser("2-spin fatband (3-color bubbles) from VASP5.4.4 PROCAR lm decomposed.")
    ap.add_argument("--dirname", default=".")
    ap.add_argument("--elements", default=None, help="filter elements, e.g. 'Mo' or 'Ru,Br'. default all.")
    ap.add_argument("--orbitals", default="dz2,dxy,dx2-y2",
                    help="exactly 3 orbitals, e.g. 'dxy,dyz,dx2-y2'")
    ap.add_argument("--fermi", type=float, default=None)
    ap.add_argument("--emin", type=float, default=-1.2)
    ap.add_argument("--emax", type=float, default=1.2)
    ap.add_argument("--out", default="fatband_2spin_like_target.png")
    ap.add_argument("--dpi", type=int, default=400)

    # visual knobs
    ap.add_argument("--plain_color", default="0.82")
    ap.add_argument("--plain_lw", type=float, default=1.1)
    ap.add_argument("--bubble_scale", type=float, default=220.0)
    ap.add_argument("--bubble_pow", type=float, default=1.0)
    ap.add_argument("--bubble_clip", type=float, default=1.0)

    # force spin if you know it's ISPIN=2 but PROCAR is weird
    ap.add_argument("--force_nspin", type=int, default=None, help="set to 2 to force 2-spin parsing")

    args = ap.parse_args()
    d = os.path.abspath(args.dirname)

    procar = os.path.join(d, "PROCAR")
    poscar = os.path.join(d, "POSCAR")
    kpoints = os.path.join(d, "KPOINTS")
    outcar = os.path.join(d, "OUTCAR")

    for p in [procar, poscar, kpoints]:
        if not os.path.exists(p):
            raise FileNotFoundError(f"Missing file: {p}")

    # atoms selection
    elements, counts = read_poscar_elements_counts(poscar)
    pick = None
    if args.elements:
        pick = [x.strip() for x in args.elements.split(",") if x.strip()]
    sel_ions_1b = element_to_atom_indices_1based(elements, counts, pick)
    sel_ions_0b = sel_ions_1b - 1

    # fermi
    fermi = args.fermi
    if fermi is None:
        f0 = read_fermi_from_outcar(outcar)
        fermi = f0 if f0 is not None else 0.0

    # parse PROCAR (auto spin)
    kpts, E, W, nk, nb, nion, nspin, kpt1_count = parse_procar_lm_decomposed_autospin(
        procar, force_nspin=args.force_nspin
    )

    # kpath labels
    nodes = parse_vaskit_kpoints_nodes(kpoints)
    knames, kticks = make_kticks_knames(nodes, nk)

    # orbitals (must be 3)
    orb_names = [x.strip() for x in args.orbitals.split(",") if x.strip()]
    if len(orb_names) != 3:
        raise RuntimeError(f"--orbitals must give exactly 3 orbitals. Got: {orb_names}")

    oidx = []
    for n in orb_names:
        key = normalize_orb(n)
        if key not in ORBITAL_INDEX:
            raise RuntimeError(f"Unknown orbital '{n}'. Allowed: {sorted(ORBITAL_INDEX.keys())}")
        oidx.append(ORBITAL_INDEX[key])

    # weights sum over selected ions -> (nk, nb, nspin)
    def orb_weight(orb_i: int) -> np.ndarray:
        return W[:, :, sel_ions_0b, orb_i, :].sum(axis=2)

    wA = orb_weight(oidx[0])
    wB = orb_weight(oidx[1])
    wC = orb_weight(oidx[2])

    def bubble_size(w):
        ww = np.clip(w, 0.0, args.bubble_clip)
        ww = np.power(ww, args.bubble_pow)
        return args.bubble_scale * ww

    sA, sB, sC = bubble_size(wA), bubble_size(wB), bubble_size(wC)

    # x index along k
    x = np.arange(nk, dtype=float)
    XX = np.repeat(x[:, None], nb, axis=1).ravel()

    # colors
    C_BLUE = "#1f4aa8"
    C_RED  = "#e53935"
    C_ORNG = "#f2a400"
    colors = [C_BLUE, C_RED, C_ORNG]

    # legend labels
    legend_map = {
        "dz2": r"$d_{z^2}$",
        "dxy": r"$d_{xy}$",
        "x2-y2": r"$d_{x^2-y^2}$",
        "dxz": r"$d_{xz}$",
        "dyz": r"$d_{yz}$",
        "px": r"$p_x$",
        "py": r"$p_y$",
        "pz": r"$p_z$",
        "s": r"$s$",
    }
    leg_labels = [legend_map.get(normalize_orb(n), rf"${n}$") for n in orb_names]

    # ---- plot
    fig, ax = plt.subplots(figsize=(3.3, 3.3), dpi=140)

    # base bands: plot ALL spins (overlay, same style)
    for sp in range(nspin):
        ax.plot(x, (E[:, :, sp] - fermi), color=args.plain_color, lw=args.plain_lw, zorder=1)

    # scatters: plot ALL spins
    def draw_scatter(S, color, z):
        for sp in range(nspin):
            YY = (E[:, :, sp] - fermi).ravel()
            SS = S[:, :, sp].ravel()
            ax.scatter(XX, YY, s=SS, c=color, marker="o", linewidths=0, alpha=1.0, zorder=z)

    draw_scatter(sA, colors[0], z=4)
    draw_scatter(sB, colors[1], z=5)
    draw_scatter(sC, colors[2], z=3)

    # dashed references
    ax.axhline(0.0, color="0.55", ls="--", lw=0.8, zorder=0)
    for t in kticks[1:-1]:
        ax.axvline(t, color="0.55", ls="--", lw=0.8, zorder=0)

    # axes formatting
    ax.set_xlim(0, nk - 1)
    ax.set_ylim(args.emin, args.emax)
    ax.set_yticks([-1.2, -0.6, 0.0, 0.6, 1.2])
    ax.set_ylabel("Energy (eV)", fontsize=12)

    ax.set_xticks(kticks)
    ax.set_xticklabels(knames, fontsize=12)

    ax.tick_params(axis="y", labelsize=11, width=1.0, length=4)
    ax.tick_params(axis="x", width=1.0, length=4)

    for spn in ax.spines.values():
        spn.set_linewidth(1.0)

    ax.grid(False)

    # top legend
    proxies = [
        Line2D([0], [0], marker="o", color="none",
               markerfacecolor=colors[i], markeredgecolor="none", markersize=5.2)
        for i in range(3)
    ]
    ax.legend(
        proxies, leg_labels,
        loc="upper center",
        bbox_to_anchor=(0.5, 1.10),
        ncol=3,
        frameon=False,
        handletextpad=0.25,
        columnspacing=0.8,
        fontsize=12,
    )

    plt.tight_layout(pad=0.6)
    fig.savefig(args.out, dpi=args.dpi, bbox_inches="tight")

    # guaranteed stdout
    print("[OK] saved:", args.out)
    print(f"Parsed PROCAR: nk={nk}, nb={nb}, nion={nion}, detected nspin={nspin} (k-point 1 count={kpt1_count})")
    print("Fermi used:", fermi)
    print("Selected ions (1-based) count:", len(sel_ions_1b), "example:", sel_ions_1b[:10].tolist())
    print("Orbitals:", orb_names, "-> indices:", oidx)
    print("K-path nodes:", nodes)
    print("K ticks:", kticks)
    print("K names:", knames)


if __name__ == "__main__":
    main()


```

使用方法：

```shell
python fatband.py --orbitals dxy,dx2-y2,dyz --out test.png
```

## <center>脚本2</center>

更美观，且支持对每个轨道自定义颜色，支持任意数量的轨道组合，除了f轨道

```python

#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os
import re
import argparse
from typing import List, Tuple, Optional, Dict

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
from matplotlib.colors import to_rgba


# =========================
# POSCAR
# =========================
def read_poscar_elements_counts(poscar_path: str) -> Tuple[List[str], List[int]]:
    with open(poscar_path, "r", encoding="utf-8", errors="ignore") as f:
        lines = [ln.strip() for ln in f.readlines() if ln.strip()]
    if len(lines) < 8:
        raise RuntimeError(f"POSCAR too short: {poscar_path}")
    elements = lines[5].split()
    counts = [int(x) for x in lines[6].split()]
    return elements, counts


def element_to_atom_indices_1based(elements: List[str], counts: List[int], pick: Optional[List[str]]) -> np.ndarray:
    total = sum(counts)
    if not pick:
        return np.arange(1, total + 1, dtype=int)
    pick_set = set(pick)
    out = []
    s = 1
    for el, n in zip(elements, counts):
        if el in pick_set:
            out.extend(range(s, s + n))
        s += n
    if not out:
        raise RuntimeError(f"Selected elements {pick} not found in POSCAR elements={elements}")
    return np.array(out, dtype=int)


# =========================
# OUTCAR: E-fermi
# =========================
def read_fermi_from_outcar(outcar_path: str) -> Optional[float]:
    if not os.path.exists(outcar_path):
        return None
    pat = re.compile(r"E-fermi\s*:\s*([-\d\.]+)")
    fermi = None
    with open(outcar_path, "r", encoding="utf-8", errors="ignore") as f:
        for ln in f:
            m = pat.search(ln)
            if m:
                fermi = float(m.group(1))
    return fermi


# =========================
# KPOINTS (VASPKIT)
# =========================
def pretty_label(lbl: str) -> str:
    s = lbl.strip()
    if s.upper() == "GAMMA":
        return r"$\Gamma$"
    if s in ("K'", "K’", "Kp", "KP"):
        return r"$K'$"
    return rf"${s}$"


def parse_vaskit_kpoints_nodes(kpoints_path: str) -> List[str]:
    coord_pat = re.compile(
        r"^\s*([-\d\.]+)\s+([-\d\.]+)\s+([-\d\.]+)\s+([A-Za-z0-9\-\+'’]+)\s*$"
    )
    labels_all = []
    with open(kpoints_path, "r", encoding="utf-8", errors="ignore") as f:
        for ln in f:
            m = coord_pat.match(ln.strip())
            if m:
                labels_all.append(m.group(4).strip())
    if len(labels_all) < 2:
        raise RuntimeError("Failed to parse high-symmetry labels from KPOINTS.")

    compressed = []
    for lab in labels_all:
        if not compressed or lab != compressed[-1]:
            compressed.append(lab)

    cleaned = []
    i = 0
    while i < len(compressed):
        cleaned.append(compressed[i])
        if i + 2 < len(compressed) and compressed[i + 1] == compressed[i + 2]:
            i += 2
        else:
            i += 1
    return cleaned


def make_kticks_knames(nodes: List[str], nk: int) -> Tuple[List[str], List[int]]:
    nseg = len(nodes) - 1
    kticks = [int(round(i * (nk - 1) / nseg)) for i in range(len(nodes))]
    kticks[0] = 0
    kticks[-1] = nk - 1
    knames = [pretty_label(x) for x in nodes]
    return knames, kticks


# =========================
# Orbitals (ONLY s/p/d allowed)
# =========================
ORBITAL_INDEX = {
    "s": 0,
    "py": 1, "pz": 2, "px": 3,
    "dxy": 4, "dyz": 5, "dz2": 6, "dxz": 7, "x2-y2": 8,
}

def normalize_orb(s: str) -> str:
    t = s.strip().lower().replace(" ", "").replace("^", "").replace("_", "")
    if t in ("dx2-y2", "dx2y2", "x2y2", "x2-y2"):
        return "x2-y2"
    return t

def expand_orbitals(orb_str: str) -> List[str]:
    raw = [x for x in re.split(r"[,\+;\s]+", orb_str) if x.strip()]
    out = []
    for tok in raw:
        k = normalize_orb(tok)
        if k == "s":
            out.append("s")
        elif k == "p":
            out += ["px", "py", "pz"]
        elif k == "d":
            out += ["dxy", "dyz", "dz2", "dxz", "x2-y2"]
        else:
            if k not in ORBITAL_INDEX:
                raise RuntimeError(
                    f"Illegal orbital token '{tok}'. Only s/p/d orbitals are allowed: "
                    f"{sorted(ORBITAL_INDEX.keys())} and groups s/p/d."
                )
            out.append(k)

    seen = set()
    uniq = []
    for x in out:
        if x not in seen:
            uniq.append(x)
            seen.add(x)
    return uniq

def latex_label(orb: str) -> str:
    if orb == "s":
        return r"$s$"
    if orb in ("px", "py", "pz"):
        return rf"$p_{{{orb[-1]}}}$"
    if orb == "dz2":
        return r"$d_{z^2}$"
    if orb == "dxy":
        return r"$d_{xy}$"
    if orb == "dyz":
        return r"$d_{yz}$"
    if orb == "dxz":
        return r"$d_{xz}$"
    if orb == "x2-y2":
        return r"$d_{x^2-y^2}$"
    return rf"${orb}$"


# =========================
# Robust PROCAR parser: auto-detect nspin
# =========================
def parse_procar_lm_decomposed_autospin(procar_path: str, force_nspin: Optional[int] = None):
    with open(procar_path, "r", encoding="utf-8", errors="ignore") as f:
        lines = f.readlines()

    m = re.search(
        r"#\s*of\s*k-points:\s*([0-9]+)\s*#\s*of\s*bands:\s*([0-9]+)\s*#\s*of\s*ions:\s*([0-9]+)",
        "".join(lines)
    )
    if not m:
        raise RuntimeError("Failed to parse PROCAR header '# of k-points/bands/ions'.")

    nk = int(m.group(1)); nb = int(m.group(2)); nion = int(m.group(3))
    norb = 9

    header_text = "".join(lines[:80]).lower()
    kpt1_pat = re.compile(r"^\s*k-point\s+1\s*:", re.IGNORECASE)
    kpt1_count = sum(1 for ln in lines if kpt1_pat.match(ln))

    if force_nspin is not None:
        nspin = int(force_nspin)
    else:
        if "spin component" in header_text:
            nspin = 2
        else:
            nspin = 2 if kpt1_count >= 2 else 1

    kpoints = np.zeros((nk, 3), dtype=float)
    energies = np.full((nk, nb, nspin), np.nan, dtype=float)
    weights  = np.zeros((nk, nb, nion, norb, nspin), dtype=float)

    spin_pat = re.compile(r"spin\s+component\s+([12])", re.IGNORECASE)
    kpt_pat  = re.compile(r"^\s*k-point\s+(\d+)\s*:\s*([-\d\.Ee+]+)\s+([-\d\.Ee+]+)\s+([-\d\.Ee+]+)")
    band_pat = re.compile(r"^\s*band\s+(\d+)\s*#\s*energy\s+([-\d\.Ee+]+)")
    ion_header_pat = re.compile(
        r"^\s*ion\s+s\s+py\s+pz\s+px\s+dxy\s+dyz\s+dz2\s+dxz\s+x2-y2\s+tot",
        re.IGNORECASE
    )

    cur_spin = 0
    cur_k = -1
    cur_b = -1

    seen_k_cycle = 0
    last_k_index = None

    i = 0
    while i < len(lines):
        ln = lines[i]

        ms = spin_pat.search(ln)
        if ms:
            cur_spin = int(ms.group(1)) - 1
            i += 1
            continue

        mk = kpt_pat.match(ln)
        if mk:
            k_index_1b = int(mk.group(1))

            if force_nspin is None and ("spin component" not in header_text):
                if last_k_index is not None and k_index_1b == 1 and last_k_index != 1:
                    seen_k_cycle += 1
                cur_spin = min(seen_k_cycle, nspin - 1)

            last_k_index = k_index_1b
            cur_k = k_index_1b - 1

            if cur_spin == 0:
                kpoints[cur_k, :] = [float(mk.group(2)), float(mk.group(3)), float(mk.group(4))]
            i += 1
            continue

        mb = band_pat.match(ln)
        if mb:
            cur_b = int(mb.group(1)) - 1
            energies[cur_k, cur_b, cur_spin] = float(mb.group(2))
            i += 1
            continue

        if ion_header_pat.match(ln):
            for j in range(nion):
                row = lines[i + 1 + j].split()
                ion_id = int(row[0]) - 1
                vals = [float(x) for x in row[1:1+norb]]
                weights[cur_k, cur_b, ion_id, :, cur_spin] = vals
            i = i + 1 + nion + 1
            continue

        i += 1

    if np.isnan(energies).any():
        nan_pos = np.argwhere(np.isnan(energies))
        raise RuntimeError(f"PROCAR parse incomplete: energies has NaNs, e.g. {nan_pos[:8].tolist()}")

    return kpoints, energies, weights, nk, nb, nion, nspin, kpt1_count


# =========================
# Colors: fixed by orbital + optional explicit list
# =========================
def parse_fixed_colors(s: Optional[str]) -> Dict[str, str]:
    if not s:
        return {}
    out = {}
    for part in s.split(","):
        part = part.strip()
        if not part:
            continue
        if "=" not in part:
            raise RuntimeError(f"Bad --fixed_colors token '{part}', expect key=#RRGGBB")
        k, v = part.split("=", 1)
        k = normalize_orb(k)
        v = v.strip()
        # validate color string now (raise if invalid)
        to_rgba(v)
        out[k] = v
    return out

def parse_colors_list(s: Optional[str]) -> Optional[List[str]]:
    """
    --colors "#2f4aa8,#e53935,#f2a400"
    """
    if not s:
        return None
    cols = [c.strip() for c in s.split(",") if c.strip()]
    if not cols:
        return None
    for c in cols:
        to_rgba(c)  # validate
    return cols

def auto_color_list(n: int) -> List[str]:
    if n <= 10:
        cmap = plt.get_cmap("tab10")
        return [cmap(i) for i in range(n)]
    cmap = plt.get_cmap("tab20")
    return [cmap(i % 20) for i in range(n)]

def assign_colors(orbs: List[str], fixed: Dict[str, str], colors_list: Optional[List[str]]) -> List:
    """
    Priority:
      1) fixed_colors per-orbital
      2) --colors list by order (cycled)
      3) auto colors
    """
    n = len(orbs)
    if colors_list:
        cols = colors_list
        out = []
        for i, o in enumerate(orbs):
            out.append(fixed.get(o, cols[i % len(cols)]))
        return out

    auto = auto_color_list(n)
    return [fixed.get(o, auto[i]) for i, o in enumerate(orbs)]


# =========================
# Main
# =========================
def main():
    ap = argparse.ArgumentParser("Fatband (s/p/d only) any number of orbitals, custom colors supported.")
    ap.add_argument("--dirname", default=".")
    ap.add_argument("--elements", default=None, help="e.g. 'Mo' or 'Ru,Br'. default all atoms.")
    ap.add_argument("--orbitals", required=True,
                    help="Any number. Tokens can be s,p,d or explicit: px,py,pz,dxy,dyz,dz2,dxz,x2-y2. "
                         "Example: 'd' or 'dxy dyz dx2-y2' or 'p dz2'.")
    ap.add_argument("--fixed_colors", default=None,
                    help="Fixed colors by orbital: 'dz2=#2f4aa8,dxy=#e53935,x2-y2=#f2a400'")
    ap.add_argument("--colors", default=None,
                    help="Optional ordered color list: '#2f4aa8,#e53935,#f2a400' (cycled if shorter than orbitals)")

    ap.add_argument("--fermi", type=float, default=None)
    ap.add_argument("--emin", type=float, default=-1.2)
    ap.add_argument("--emax", type=float, default=1.2)
    ap.add_argument("--out", default="fatband_anyorb_spd.png")
    ap.add_argument("--dpi", type=int, default=400)

    ap.add_argument("--plain_color", default="0.82")
    ap.add_argument("--plain_lw", type=float, default=1.1)
    ap.add_argument("--bubble_scale", type=float, default=150.0)
    ap.add_argument("--bubble_pow", type=float, default=1.0)
    ap.add_argument("--bubble_clip", type=float, default=1.0)

    ap.add_argument("--force_nspin", type=int, default=None, help="force 2 if needed")

    args = ap.parse_args()
    d = os.path.abspath(args.dirname)

    procar = os.path.join(d, "PROCAR")
    poscar = os.path.join(d, "POSCAR")
    kpoints = os.path.join(d, "KPOINTS")
    outcar = os.path.join(d, "OUTCAR")

    for p in [procar, poscar, kpoints]:
        if not os.path.exists(p):
            raise FileNotFoundError(f"Missing file: {p}")

    # orbitals expand
    orbs = expand_orbitals(args.orbitals)
    if len(orbs) == 0:
        raise RuntimeError("No valid orbitals parsed from --orbitals")

    # atoms selection
    elements, counts = read_poscar_elements_counts(poscar)
    pick = None
    if args.elements:
        pick = [x.strip() for x in args.elements.split(",") if x.strip()]
    sel_ions_1b = element_to_atom_indices_1based(elements, counts, pick)
    sel_ions_0b = sel_ions_1b - 1

    # fermi
    fermi = args.fermi
    if fermi is None:
        f0 = read_fermi_from_outcar(outcar)
        fermi = f0 if f0 is not None else 0.0

    # parse PROCAR
    kpts, E, W, nk, nb, nion, nspin, kpt1_count = parse_procar_lm_decomposed_autospin(
        procar, force_nspin=args.force_nspin
    )

    # kpath labels
    nodes = parse_vaskit_kpoints_nodes(kpoints)
    knames, kticks = make_kticks_knames(nodes, nk)

    # colors
    fixed = parse_fixed_colors(args.fixed_colors)
    colors_list = parse_colors_list(args.colors)
    colors = assign_colors(orbs, fixed, colors_list)

    # bubble mapping
    def bubble_size(w):
        ww = np.clip(w, 0.0, args.bubble_clip)
        ww = np.power(ww, args.bubble_pow)
        return args.bubble_scale * ww

    x = np.arange(nk, dtype=float)
    XX = np.repeat(x[:, None], nb, axis=1).ravel()

    # compute sizes for each orbital
    sizes_list = []
    for o in orbs:
        oi = ORBITAL_INDEX[o]
        w = W[:, :, sel_ions_0b, oi, :].sum(axis=2)  # (nk,nb,nspin)
        sizes_list.append(bubble_size(w))

    # ---- plot
    fig, ax = plt.subplots(figsize=(3.3, 3.3), dpi=140)

    # base bands: all spins
    for sp in range(nspin):
        ax.plot(x, (E[:, :, sp] - fermi), color=args.plain_color, lw=args.plain_lw, zorder=1)

    # scatters
    for i, o in enumerate(orbs):
        S = sizes_list[i]
        col = colors[i]
        z = 3 + i
        for sp in range(nspin):
            YY = (E[:, :, sp] - fermi).ravel()
            SS = S[:, :, sp].ravel()
            ax.scatter(XX, YY, s=SS, c=[col], marker="o", linewidths=0, alpha=1.0, zorder=z)

    # dashed refs
    ax.axhline(0.0, color="0.55", ls="--", lw=0.8, zorder=0)
    for t in kticks[1:-1]:
        ax.axvline(t, color="0.55", ls="--", lw=0.8, zorder=0)

    # axes formatting
    ax.set_xlim(0, nk - 1)
    ax.set_ylim(args.emin, args.emax)
    ax.set_yticks([-1.2, -0.6, 0.0, 0.6, 1.2])
    ax.set_ylabel("Energy (eV)", fontsize=12)
    ax.set_xticks(kticks)
    ax.set_xticklabels(knames, fontsize=12)
    ax.tick_params(axis="y", labelsize=11, width=1.0, length=4)
    ax.tick_params(axis="x", width=1.0, length=4)
    for spn in ax.spines.values():
        spn.set_linewidth(1.0)
    ax.grid(False)

    # legend
    proxies = [
        Line2D([0], [0], marker="o", color="none",
               markerfacecolor=colors[i], markeredgecolor="none", markersize=5.2)
        for i in range(len(orbs))
    ]
    labels = [latex_label(o) for o in orbs]
    ncol = min(len(orbs), 5)
    ax.legend(
        proxies, labels,
        loc="upper center",
        bbox_to_anchor=(0.5, 1.16),
        ncol=ncol,
        frameon=False,
        handletextpad=0.25,
        columnspacing=0.8,
        fontsize=12,
    )

    plt.tight_layout(pad=0.6)
    fig.savefig(args.out, dpi=args.dpi, bbox_inches="tight")

    print("[OK] saved:", args.out)
    print(f"Parsed PROCAR: nk={nk}, nb={nb}, nion={nion}, detected nspin={nspin} (k-point 1 count={kpt1_count})")
    print("Fermi used:", fermi)
    print("Selected ions (1-based) count:", len(sel_ions_1b), "example:", sel_ions_1b[:10].tolist())
    print("Orbitals expanded:", orbs)
    print("Colors used:", colors)
    print("K-path nodes:", nodes)


if __name__ == "__main__":
    main()


```

使用方法：
```shell

python 2fatband.py --orbitals "dxy dyz dz2" --fixed_colors "dz2=#2f4aa8,dxy=#e53935,dyz=#f2a400" --out test.png

```

## <center>脚本3</center>

对全局字体加深要求，全部加粗，且规定字体为Times New Roman。




