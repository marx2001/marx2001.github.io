---
layout: post
title: "pythTB的学习_mesh类"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20251209-PythonTB_mesh
---


# <center>Tutorials​</center>

本教程将演示如何在组合布里渊区（BZ）与参数空间中创建自定义网格与环绕路径。
```python

from pythtb import Mesh
import numpy as np

```


Mesh对象接受以下参数：

•axis_types：字符串列表，定义每个坐标轴的类型。选项为 "k"（晶格动量，约化单位）和 "l"（绝热参数）。

•axis_names（可选）：字符串列表，定义每个坐标轴的名称，主要用于绝热循环（示例可见“三格点 Thouless 泵”案例）。

•dim_k（可选）：整数，定义 k 空间的维度。当 "k"轴的数量少于 dim_k时（例如在二维布里渊区中沿一维路径采样）必须提供此参数。

在下面的代码单元中，我们将在二维k空间中创建一个仅包含单个k轴的网格。这意味着该网格是二维布里渊区（BZ）中的一条路径。我们将使用 build_custom()方法直接指定网格点。这里我们创建了一条从 Γ
点 [0, 0]​ 经过 X点 [0.5, 0.5]​ 到下一个单元中的 Γ点 [1, 1]​ 的路径。

```python

mesh = Mesh(["k"], dim_k=2)
points = np.linspace(
    [0, 0], [1, 1], 10, endpoint=False
)  # path from (0, 0) to (0.5, 0.5) to (1, 1)
mesh.build_custom(points)

```
我们可以通过 points属性访问网格点。请注意，网格中的每个点都是一个二维向量，对应于两个 k 空间维度。

```python

print("Mesh shape:", mesh.shape)
print("Mesh points along the path from (0,0) to (1,1):")
print(mesh.points)

```

结果：

```python

Mesh shape: (10, 2)
Mesh points along the path from (0,0) to (1,1):
[[0.  0. ]
 [0.1 0.1]
 [0.2 0.2]
 [0.3 0.3]
 [0.4 0.4]
 [0.5 0.5]
 [0.6 0.6]
 [0.7 0.7]
 [0.8 0.8]
 [0.9 0.9]]

```

我们可以通过打印对象来查看网格信息。这会告诉我们：

网格类型（"path" 路径 或 "grid" 网格）


k空间和参数空间的维度数


网格点的总数


网格数组的形状


k轴（类型（k）、名称、点数）


参数空间轴（类型（l）、名称、点数）


哪些轴是循环（周期性）的，哪些不是


网格中存在的环（若有）

```python

print(mesh)

```


```python

Mesh Summary
========================================
Type: path
Dimensionality: 2 k-dim(s) + 0 λ-dim(s)
Number of mesh points: 10
Full shape: (10, 2)
k-axes: [Axis(type=k, name=k_0, size=10)]
λ-axes: []
Loops: None

```

代码本身无法自动判断在端点未包含时，哪些轴应对布里渊区（BZ）或参数空间进行“卷绕”，因此需要手动指定。这对于正确布洛赫波函数的周期性边界条件非常重要。

您可以通过调用 loop方法来声明一个轴对布里渊区进行卷绕。该方法接受以下参数：

axis_idx：要卷绕的轴索引（从0开始计数）。

component_idx：在组合的 (k, λ) 向量中对应的分量索引（从0开始计数）。

winds_bz：布尔值，指示该轴是否通过倒格矢卷绕布里渊区（True表示是）。

closed：布尔值，指示该轴是否包含端点（即是否为闭合的轴）（False表示不包含）。

在您的例子中，设置了：

将网格的第一个（且唯一一个）轴 (axis_idx=0) 设置为卷绕第一个k空间维度 (component_idx=0)，调用 loop(axis_idx=0, component_idx=0, winds_bz=True, closed=False)。

为了也对第二个k空间维度进行卷绕，再次调用 loop方法，但这次设置 component_idx=1（即 axis_idx=0, component_idx=1, winds_bz=True, closed=False)）。

调用完成后，您会看到网格信息现在会显示这两个轴都在卷绕布里渊区。

注意：

当使用k点时，应通过设置 winds_bz参数来明确该轴是否绕布里渊区（BZ）倒格矢一周。这确保了布洛赫波函数在周期性边界条件下得到正确处理。

若该轴绕布里渊区一周（例如跨越整个布里渊区的高对称路径），应设置为 winds_bz=True。

若该轴不环绕布里渊区（例如布里渊区内部的小环形路径，如狄拉克点周围的闭合环路），则应设置为 winds_bz=False。

此设置对确保波函数相位和拓扑计算的正确性至关重要。


```python

# Wind the first k-space dimension
mesh.loop(axis_idx=0, component_idx=0, winds_bz=True, closed=False)

# Now wind the second k-space dimension
mesh.loop(axis_idx=0, component_idx=1, winds_bz=True, closed=False)
print(mesh)

```

```python

Mesh Summary
========================================
Type: path
Dimensionality: 2 k-dim(s) + 0 λ-dim(s)
Number of mesh points: 10
Full shape: (10, 2)
k-axes: [Axis(type=k, name=k_0, size=10)]
λ-axes: []
Loops: (axis 0, comp 0, winds_bz=yes, closed=no), (axis 0, comp 1, winds_bz=yes, closed=no)

```

我们将进行与之前相同的操作，但这次会将布里渊区（BZ）的端点包含在内。

注意：

Mesh类具备自动检测功能：如果 k 分量的起点和终点在模 1 下相等（即该轴是闭合的），则会自动将该轴识别为环绕布里渊区。因此，即使在以 Γ 点为中心（k 分量范围在 [-0.5, 0.5] 内）的网格中，如果包含了端点（±0.5），该类仍可检测到该轴环绕布里渊区。

```python

mesh = Mesh(dim_k=2, axis_types=["k"])

# Path from (-0.5,-0.5) to (0.5, 0.5) including endpoints (endpoint=True)
points = np.linspace([-0.5, -0.5], [0.5, 0.5], 10, endpoint=True)

mesh.build_custom(points)
print(mesh)

```

```python

Mesh Summary
========================================
Type: path
Dimensionality: 2 k-dim(s) + 0 λ-dim(s)
Number of mesh points: 10
Full shape: (10, 2)
k-axes: [Axis(type=k, name=k_0, size=10)]
λ-axes: []
Loops: (axis 0, comp 0, winds_bz=yes, closed=yes), (axis 0, comp 1, winds_bz=yes, closed=yes)

```