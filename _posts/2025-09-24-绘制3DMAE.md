---
layout: post
title: "绘制3DMAE的流程（原创脚本与流程）"
subtitle: "Scripts made by myself"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20250924-3DMAE
---

## <center>3DMAE绘制流程</center>

**<span style="font-size: 120%"> 1. 计算3DMAE数据</span>**


以MPSS为例，其结构如图所示

<div align="center"><img src="/img/vasp计算能带/bg-s1.png" alt="MPSS结构图" style="width:500px; height:auto;"/></div>
<div align="center"><img src="/img/vasp计算能带/bg-s2.png" alt="MPSS结构图" style="width:500px; height:auto;"/></div>

首先，准备输入文件VASPKIT.in文件，POSCAR、POTCAR、KPOINTS、mrx.py以及CHGCAR。

VASPKIT.in文件由自己编写，内容如下

```python
2                           ! 1 for preprocess, 2 for postprocess
0 360 24                       ! 0<= azimuth angle phi in spherical coordinate system <=360 with a increment of 30 degrees, 12 points in total
0 180 13                       ! 0<= polar angle theta in spherical coordinate system <=180 with a increment of 15 degrees, 13 points in total
```

INCAR文件如下：

```python

#General
PREC = ACCURATE
ISTART= 0
ICHARG= 1
ENCUT = 500
EDIFF = 1E-6
EDIFFG = -0.01
LREAL = .F.
NPAR = 4
NSW= 0
IBRION = -1
ISIF = 2
NELM=300
ISMEAR = 0
SIGMA = 0.05
LCHARG = .F.
LWAVE = .F.
POTIM = 0.1

#Magnetic properties

ISPIN=2

MAGMOM = 0  0  0   0 0 4   24*0.0

NELMIN = 6
LORBIT = 11
ISYM = 0
LSORBIT = .True.
LMAXMIX = 4  

LDAU = .TRUE.
LDAUTYPE = 2
LDAUL = 2  2 -1 -1
LDAUU = 0.5 2.0 0.0 0.0
LDAUJ = 0.0 0.0 0.0 0.0
LDAUPRINT = 2

```

提交计算脚本，脚本内容如下：
```python

#!/bin/bash 
#PBS -l nodes=1:ppn=64
#PBS -l walltime=640:01:00 
#PBS -j oe
#PBS -q sugon
#PBS -N mae

cd $PBS_O_WORKDIR

echo job id is $PBS_JOBID | tee  pbslog
echo run nodes is following: | tee -a pbslog
cat $PBS_NODEFILE | tee  -a pbslog

echo begin time is `date` | tee -a  pbslog
id=`echo $PBS_JOBID|awk -F. '{print $1}' `
NP=`cat $PBS_NODEFILE|wc -l`


source /public/software/profile.d/compiler_intel-compiler-2021.3.0.sh 
source  /public/software/profile.d/mpi_intelmpi-2021.3.0.sh 
RUN_1=/public/home/cssong/app/vasp/intel_2021.3.0/5.4.4/vasp_std
RUN_2=/public/home/cssong/app/vasp/intel_2021.3.0/5.4.4/vasp_ncl
cat $PBS_NODEFILE | uniq -c | awk '{ printf("%s:%s\n", $2, $1); }' >> $PBS_JOBID-$PBS_JOBCOOKIE.hosts

shopt -s extglob
for i in +([0-9])?(.+([0-9]))_+([0-9])?(.+([0-9]))
do

       cd $i
       mpirun  -np $NP  ${RUN_2}>&log
cd ..
done
```


**<span style="font-size: 120%"> 2. 数据后处理与画图</span>**

1. 计算完成后，修改VASPKIT.in文件，将第一行的1改为2，产生MAE.dat数据文件。

2. 运行mrx.py，产生四个txt文件

3. 打开Origin，同一个系统框内创建四个矩阵。如下图所示，点击画红框的按钮，选择“插入”

<div align="center"><img src="/img/vasp计算3DMAE/bg-m1.png" alt="MAE图" style="width:600px; height:auto;"/></div>

4. ctrl+A全选，并于工具栏中点击“绘图”-“参数曲面图”，即可产生3DMAE图像。

5. 双击页面空白的地方，弹出“图层”框，选择“平面”，将XY、YZ、ZX取消勾选，再旋转到合适的角度，即可得到3DMAE图。如果比例不满意，可以选择“坐标轴”选项，修改某一轴的长度即可找到优美的比例。


PS：mrx.py为原创脚本，其代码如下：

```python

import numpy as np
from scipy.interpolate import griddata

# ========================= 参数设置 =========================
input_file = "MAE.dat"     # 输入文件名（确保文件在当前目录）
output_prefix = "MAE_3D"   # 输出文件前缀
nphi = 500                 # 极角网格点数 (0到π)
ntheta = 500               # 方位角网格点数 (0到2π)
# ===========================================================

# ------------------------- 1. 读取数据 -------------------------
print("正在读取数据...")
data = np.loadtxt(input_file, skiprows=1)  # 跳过标题行
phi_deg = data[:, 0]       # 第一列：极角φ（单位：度）
theta_deg = data[:, 1]     # 第二列：方位角θ（单位：度）
R = data[:, 2]             # 第三列：R值

# ------------------------- 2. 角度转换 -------------------------
phi = np.deg2rad(phi_deg)  # 转换为弧度 [0, π]
theta = np.deg2rad(theta_deg)  # 转换为弧度 [0, 2π]

# ------------------------- 3. 生成新网格 -----------------------
print("生成插值网格...")
phinew = np.linspace(0, np.pi, nphi)          # 极角范围 [0, π]
thetanew = np.linspace(0, 2*np.pi, ntheta)    # 方位角范围 [0, 2π]
xx, yy = np.meshgrid(phinew, thetanew, indexing='ij')  # 创建网格

# ------------------------- 4. 插值计算 -------------------------
print("正在进行立方插值...")
points = np.column_stack((phi, theta))        # 原始数据点坐标
xi = np.column_stack((xx.ravel(), yy.ravel())) # 新网格点坐标

# 使用立方插值计算Rnew，并处理可能的NaN值
Rnew = griddata(points, R, xi, method='cubic')
Rnew = Rnew.reshape(xx.shape)                  # 转换为矩阵形状
Rnew = np.nan_to_num(Rnew, nan=np.nanmean(Rnew))  # 用均值填充缺失值

# ------------------------- 5. 转换为笛卡尔坐标 ------------------
print("坐标转换中...")
x = Rnew * np.sin(xx) * np.cos(yy)
y = Rnew * np.sin(xx) * np.sin(yy)
z = Rnew * np.cos(xx)

# 生成镜像数据（关于xy平面的对称）
x_mirror = x
y_mirror = y
z_mirror = -z

# 合并原数据和镜像数据（沿极角φ方向堆叠）
x_combined = np.vstack((x, x_mirror))
y_combined = np.vstack((y, y_mirror))
z_combined = np.vstack((z, z_mirror))
R_combined = np.vstack((Rnew, Rnew))

# ------------------------- 6. 保存为Origin矩阵文件 --------------
print("保存数据文件...")
np.savetxt(f"{output_prefix}_X.txt", x_combined, delimiter='\t', fmt='%.6f')
np.savetxt(f"{output_prefix}_Y.txt", y_combined, delimiter='\t', fmt='%.6f')
np.savetxt(f"{output_prefix}_Z.txt", z_combined, delimiter='\t', fmt='%.6f')
np.savetxt(f"{output_prefix}_R.txt", R_combined, delimiter='\t', fmt='%.6f')

print("处理完成！请在当前目录查看生成的文件。")

```

也可以用Python进行3DMAE绘图，经过我的精心调试，原创脚本如下：

```python

import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import griddata
from matplotlib.colors import Normalize, LinearSegmentedColormap

# ===== 数据加载 =====
data = np.loadtxt('MAE.dat', skiprows=1)
phi = data[:, 0] * np.pi / 180
theta = data[:, 1] * np.pi / 180
R = data[:, 2]

# ===== 网格生成 =====
nphi, ntheta = 500, 500
phinew = np.linspace(0, np.pi, nphi)
thetanew = np.linspace(0, 2*np.pi, ntheta)
xx, yy = np.meshgrid(phinew, thetanew)

# ===== 镜像对称插值 =====
phi_mirror = np.pi - xx
theta_mirror = (yy + np.pi) % (2*np.pi)
R_upper = griddata((phi, theta), R, (xx, yy), method='cubic')
R_lower = griddata((phi, theta), R, (phi_mirror, theta_mirror), method='cubic')
Rnew = np.where(xx > np.pi/2, R_lower, R_upper)

# ===== 坐标转换 (放大 4 倍) =====
scale_factor = 4.0
x = scale_factor * Rnew * np.sin(xx) * np.cos(yy)
y = scale_factor * Rnew * np.sin(xx) * np.sin(yy)
z = scale_factor * Rnew * np.cos(xx)

# ===== 柔和渐变色 (橙-黄-绿) =====
cmap_soft = LinearSegmentedColormap.from_list(
    "OrangeYellowGreen", ["#FFA500", "#FFFF66", "#008000"]
)

# ===== 可视化 =====
fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')

# 统一颜色映射
norm = Normalize(vmin=np.min(Rnew), vmax=np.max(Rnew))
colors = cmap_soft(norm(Rnew))

surf = ax.plot_surface(
    x, y, z,
    facecolors=colors,
    rcount=300, ccount=300,
    antialiased=True
)

# ===== 视角和比例 =====
ax.view_init(elev=30, azim=-50)

# 自动保持 x,y,z 方向比例一致
ax.set_box_aspect([np.ptp(x), np.ptp(y), np.ptp(z)])

# ===== 设置坐标范围（比图形大 1.5 倍） =====
margin = 1.5
ax.set_xlim([np.min(x) * margin, np.max(x) * margin])
ax.set_ylim([np.min(y) * margin, np.max(y) * margin])
ax.set_zlim([np.min(z) * margin, np.max(z) * margin])

# ===== 坐标轴样式：只保留网格，去掉刻度数字和标签 =====
ax.tick_params(labelbottom=False, labelleft=False, labelright=False, labeltop=False)
ax.set_xlabel("")
ax.set_ylabel("")
ax.set_zlabel("")
ax.grid(True)

# 网格线颜色调浅
ax.xaxis._axinfo['grid']['color'] = (0.8, 0.8, 0.8, 1)
ax.yaxis._axinfo['grid']['color'] = (0.8, 0.8, 0.8, 1)
ax.zaxis._axinfo['grid']['color'] = (0.8, 0.8, 0.8, 1)

# ===== 颜色条（柔和渐变） =====
mappable = plt.cm.ScalarMappable(norm=norm, cmap=cmap_soft)
mappable.set_array([])
cbar = fig.colorbar(mappable, shrink=0.5, aspect=10)
cbar.set_label("")  # 去掉标签

# ===== 保存 & 显示 =====
plt.tight_layout()
plt.savefig("MAE_3D_orange_yellow_green_scaled4_margin15.png", dpi=600, bbox_inches="tight", facecolor="white")
plt.show()


```