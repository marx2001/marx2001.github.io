---
layout: post
title: "快速绘制轨道投影能带"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20251222-band
---

# <center>快速绘制轨道投影能带</center>

1. 计算

自洽计算

```shell

IBRION=-1
LCHARG=T
ICHARG=2

```

计算能带，复制上一步的CHGCAR,POSCAR,POTCAR,INCAR到当前目录，修改INCAR

```shell

ISMEAR=0
ICHARG=11

```

KPOINTS使用点模式，即KPOINTS中给出每个k点坐标，把高对称点放到文件k-point中：

```shell

0.0 0.0 0.0 g
0.5 0.0 0.0 m
0.3333333 0.3333333 0.0 k
0.0 0.0 0.0 g
-0.3333333 -0.3333333 0.0 k

```

运行脚本：

```shell

python step0.py >KPOINTS
python kp.py >KPOINTS

```
提交能带计算，等待计算完成后，下一步处理数据

kp.py的内容如下：

```python

# Python 3 version
with open("k-points", 'r+') as file:
    lines = file.readlines()

line_count = len(lines)
mesh = 20
print("k-points along high symmetry lines")
print((line_count - 1) * mesh + 1)
print("Reciprocal")

# Convert each line to a list of floats
for i in range(line_count):
    lines[i] = lines[i].strip().split()
    lines[i][0] = float(lines[i][0])
    lines[i][1] = float(lines[i][1])
    lines[i][2] = float(lines[i][2])

# Generate the k-point mesh
for i in range(line_count - 1):
    for j in range(mesh):
        # Calculate the k-point coordinates for the current position along the path
        for k in range(3):
            print(lines[i][k] + (lines[i + 1][k] - lines[i][k]) * j / (mesh + 0.0), end=' ')
        print(1.0)

# Print the last k-point
print(lines[line_count - 1][0], lines[line_count - 1][1], lines[line_count - 1][2], "1.0")


```


2. 数据处理

运行step1.sh,得到总的数据，文件名称为note-bnd

```shell

totalk=`awk '{if(NR==2)print $4}' PROCAR`
totalb=`awk '{if(NR==2)print $8}' PROCAR`
Ef=`awk '{if(NR==6)print $4}' DOSCAR`
l=`awk '/^band/{print $6}' PROCAR |wc -l`
# if ispin = 2 without of soc, we should use the following line, else comment it with # 
l=$((l/2))
awk '/^band/{print $5 - '$Ef'}' PROCAR |head -$l > bnd-up.dat
awk '/^band/{print $5 - '$Ef'}' PROCAR |tail -$l > bnd-dn.dat
echo $totalk $totalb >note-bnd
grep -A3 reciprocal OUTCAR |tail -3 |awk '{print $4,$5,$6}' >>note-bnd
cat k-points >>note-bnd
grep mesh kp.py |head -1 |cut -d= -f 2 >>note-bnd


```
运行step2.sh，得到分轨道的能带数据

```shell

#ion      s     py     pz     px    dxy    dyz    dz2    dxz  x2-y2    tot
#1        2     3      4      5     6      7      8      9    10
grep ^tot PROCAR|awk '{print $3}' >py
grep ^tot PROCAR|awk '{print $4}' >pz
grep ^tot PROCAR|awk '{print $5}' >px
grep ^tot PROCAR|awk '{print $6}' >xy
grep ^tot PROCAR|awk '{print $7}' >yz
grep ^tot PROCAR|awk '{print $8}' >z2
grep ^tot PROCAR|awk '{print $9}' >xz
grep ^tot PROCAR|awk '{print $10}' >x2


```

绘图，运行step3.py、step4.py、step5.py、step6.py，主要区别是spin的设置分为up\down\no\both,有的脚本有bug，后期再改。脚本内容如下所示：

step3.py
```python

import numpy as np
from numpy import *
import matplotlib as mpl
import os
from matplotlib import pyplot as plt
from matplotlib import rc
from matplotlib import cm
import sys
from mpl_toolkits.mplot3d import Axes3D
import matplotlib.colors as colors
rc('text', usetex=False)
plt.rc('font', family='DejaVu Sans', size=20)

max_val = 2   
min_val = -3  
step = (max_val - min_val)/10
mode = 2
spin = 'True'

fn = 'bnd.pdf'
m = open("note-bnd", 'r+')
ml = m.readlines()
ml = [ml[i].strip().split() for i in range(len(ml))]
knum = int(ml[0][0])
bnum = int(ml[0][1])

base = [ml[1], ml[2], ml[3]]
base = np.array(base)
dkvec = []
for k in range(4, len(ml)-1):
    ml[k] = [float(ml[k][j]) for j in range(3)]  # kvec to float
for k in range(5, len(ml)-1): 
    dkvec.append((np.array(ml[k]) - np.array(ml[k-1])).tolist())  # distance of kvec

def r(m, n):
    global rfinal
    global r1
    global r2
    global r3
    r1 = 0
    r2 = 0
    r3 = 0
    r1 = [float(m[0]) * float(n[0][i]) for i in range(3)]
    r2 = [float(m[1]) * float(n[1][i]) for i in range(3)]
    r3 = [float(m[2]) * float(n[2][i]) for i in range(3)]
    x = r1[0] + r2[0] + r3[0]
    y = r1[1] + r2[1] + r3[1]
    z = r1[2] + r2[2] + r3[2]
    rfinal = np.sqrt(x**2 + y**2 + z**2)

sum_k = 0
k = [0 for i in range(len(ml)-6)]
for i in range(len(ml)-6):
    r(dkvec[i], base)
    k[i] = rfinal
    sum_k = k[i] + sum_k
mesh = int(ml[len(ml)-1][0])

if mode == 1:
    x = []
else:
    x = [0]
a0 = 0
for i in range(len(ml)-6):
    for j in range(mesh):
        a0 = a0 + k[i]/(mesh + 0.0)
        x.append(a0)

# 定义高对称点标签 - 这是你原始代码中的定义
klabel = ['Γ','M','K','Γ','K']

plt.figure(figsize=(6, 10))

####### spin up ###########
with open("bnd-up.dat", 'r') as file:
    lines = file.readlines()
    data_up = np.array([float(line.strip()) for line in lines])
    data_up.resize(knum, bnum)
    bands_up = np.transpose(data_up)
    
plt.ylim(min_val, max_val)
plt.xlim(0, sum_k)

# 绘制 spin up 能带（蓝色）
for i in range(bnum):
    plt.plot(x, bands_up[i], 'b', linewidth=1.5)

####### spin down ###########
if spin == 'True':
    data_dn = np.loadtxt('bnd-dn.dat')
    data_dn.resize(knum, bnum)
    bands_dn = np.transpose(data_dn)
    
    # 绘制 spin down 能带（红色）
    for i in range(bnum):
        plt.plot(x, bands_dn[i], 'r', linewidth=1.5)

    plt.plot([0, sum_k], [0, 0], 'r-.')

hline = 0
xlab_val = [0]
for i in range(len(ml)-6):
    hline = hline + k[i]
    xlab_val.append(hline)
    
hline = 0
for i in range(len(ml)-7):
    hline = hline + k[i]
    plt.plot([hline, hline], [min_val, max_val + step], 'b-.', linewidth=1)

plt.ylabel('Energy (eV)', fontsize=25)
plt.xticks(xlab_val, klabel)  
plt.tight_layout()
plt.yticks(np.arange(min_val, max_val + step, step))
ax = plt.gca()
ax.tick_params(labelsize=20)
plt.savefig(fn, dpi=300, bbox_inches='tight')
plt.show()

```

step4.py

```python

# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc 
rc('text',usetex=False)
plt.rc('font', family='DejaVu Sans', size=20)

################
min_val = -2 
max_val = 1
step = (max_val - min_val)/10
fonts = 15
spin = 'both'  # 修改为 'both' 表示同时绘制两个自旋通道
###############
orbs=['px','py','pz','z2','x2','xy','yz','xz']
kp = ['Γ','M','K','Γ','K']

# 根据spin参数设置文件和输出名
if spin == 'up':
    bndfiles = ['bnd-up.dat']
    orb_prefixes = ['']  # 不加后缀
    figname = "Project_upbnd.pdf"
    colors = ['blue']  # spin up用蓝色
    
elif spin == 'dn':
    bndfiles = ['bnd-dn.dat']
    orb_prefixes = ['']  # 不加后缀
    figname = "Project_dnbnd.pdf"
    colors = ['red']  # spin down用红色
    
elif spin == 'both':  # 同时绘制两个自旋通道
    bndfiles = ['bnd-up.dat', 'bnd-dn.dat']
    orb_prefixes = ['', '']  # 轨道文件名相同
    figname = "Project_bothbnd.pdf"
    colors = ['blue', 'red']  # up蓝色，down红色
    
elif spin == 'no':
    bndfiles = ['bnd-up.dat']
    orb_prefixes = ['']
    figname = "Project_nospinbnd.pdf"
    colors = ['black']

m=open("note-bnd",'r+')
ml=m.readlines()
ml=[ml[i].strip().split() for i in range(len(ml))]
knum=int(ml[0][0])
bnum=int(ml[0][1])

base=[ml[1],ml[2],ml[3]]
base=np.array(base)
dkvec=[]
for k in range(4,len(ml)-1):
 ml[k]=[float(ml[k][j]) for j in range(3)]
for k in range(5,len(ml)-1): 
 dkvec.append((np.array(ml[k])-np.array(ml[k-1])).tolist())
def r(m,n):
 global rfinal
 global r1
 global r2
 global r3
 r1=0
 r2=0
 r3=0
 r1=[float(m[0])*float(n[0][i]) for i in range(3)]
 r2=[float(m[1])*float(n[1][i]) for i in range(3)]
 r3=[float(m[2])*float(n[2][i]) for i in range(3)]
 x=r1[0]+r2[0]+r3[0]
 y=r1[1]+r2[1]+r3[1]
 z=r1[2]+r2[2]+r3[2]
 rfinal=np.sqrt(x**2+y**2+z**2)
sum_k=0
k=[0 for i in range(len(ml)-6)]
for i in range(len(ml)-6):
 r(dkvec[i],base)
 k[i]=rfinal
 sum_k=k[i]+sum_k
mesh=int(ml[len(ml)-1][0])
x=[0]
a0=0
for i in range(len(ml)-6):
 for j in range(mesh):
  a0=a0+k[i]/(mesh+0.0)
  x.append(a0)

plt.figure(figsize=(20,16))

def plt_pro(i, orb_name, col, lab):
    plt.subplot(2,4,i)
    
    # 设置坐标轴范围
    plt.ylim(min_val, max_val)
    plt.xlim(0, sum_k)
    
    # 绘制费米面和对称线
    plt.plot([0,sum_k],[0,0],'r-.',linewidth=1)
    hline=0
    xlab_val = [0]
    for i in range(len(ml)-6):
        hline=hline+k[i]
        xlab_val.append(hline)
    hline=0
    for i in range(len(ml)-7):
        hline=hline+k[i]
        plt.plot([hline,hline],[min_val,max_val+step],'b-.', linewidth=1)
    
    # 处理每个自旋通道
    for spin_idx, (bndfile, color) in enumerate(zip(bndfiles, colors)):
        # 读取能带数据
        a = np.loadtxt(bndfile)
        a.resize(knum, bnum)
        b = np.transpose(a)
        
        # 绘制能带线
        for j in range(bnum):
            if spin == 'both':
                # 两个自旋通道用不同的线型和颜色
                if spin_idx == 0:  # spin up
                    plt.plot(x, b[j], '--', color=color, linewidth=1, alpha=0.6)
                else:  # spin down
                    plt.plot(x, b[j], '-', color=color, linewidth=1, alpha=0.6)
            else:
                plt.plot(x, b[j], 'k--', linewidth=1)
        
        # 读取轨道投影数据
        a2 = np.loadtxt(orb_name)
        lens = len(a2) // 2
        
        if spin == 'both':
            # 对于两个自旋通道，需要选择正确的部分
            if spin_idx == 0:  # spin up
                a2_up = a2[0:lens]
                a2_up.resize(knum, bnum)
                b2_up = np.transpose(a2_up)
                for j in range(bnum):
                    plt.scatter(x, b[j], c=color, s=b2_up[j]*300, lw=0, alpha=0.5)
            else:  # spin down
                a2_dn = a2[lens:]
                a2_dn.resize(knum, bnum)
                b2_dn = np.transpose(a2_dn)
                for j in range(bnum):
                    plt.scatter(x, b[j], c=color, s=b2_dn[j]*300, lw=0, alpha=0.5, marker='^')
        else:
            # 单个自旋通道
            if spin == 'up':
                a2 = a2[0:lens]
            elif spin == 'dn':
                a2 = a2[lens:]
            
            a2.resize(knum, bnum)
            b2 = np.transpose(a2)
            for j in range(bnum):
                plt.scatter(x, b[j], c=col, s=b2[j]*300, lw=0, alpha=0.7)
    
    # 设置图例
    if spin == 'both':
        from matplotlib.lines import Line2D
        legend_elements = [Line2D([0], [0], color='blue', linestyle='--', lw=2, label='Spin Up'),
                          Line2D([0], [0], color='red', linestyle='-', lw=2, label='Spin Down'),
                          plt.scatter([], [], c=col, s=100, label=lab)]
        plt.legend(handles=legend_elements, frameon=False, fontsize=15, loc='upper right')
    else:
        ax = plt.scatter([], [], c=col, s=100, label=lab)
        plt.legend([ax], [lab], frameon=False, fontsize=20, loc='upper right')
    
    # 设置坐标轴
    plt.ylabel('Energy (eV)')
    plt.xticks(xlab_val, kp)
    plt.tight_layout()
    plt.yticks(np.arange(min_val, max_val+step, step))
    plt.subplots_adjust(left=0.15, right=0.9, top=0.9, bottom=0.1)

# 绘制所有轨道的投影
plt_pro(1, orbs[0], "gray", r'$p_x$')
plt_pro(2, orbs[1], "gray", r'$p_y$')
plt_pro(3, orbs[2], "gray", r'$p_z$')
plt_pro(4, orbs[3], "cyan", r'$d_{z^2}$')
plt_pro(5, orbs[4], "red", r'$d_{x^2-y^2}$')
plt_pro(6, orbs[5], "red", r'$d_{xy}$')
plt_pro(7, orbs[6], "blue", r'$d_{yz}$')
plt_pro(8, orbs[7], "blue", r'$d_{xz}$')

plt.subplots_adjust(wspace=0.25, hspace=0.1)
plt.savefig(figname, format='pdf', bbox_inches='tight', dpi=300)
plt.show()

```

step5.py


```python

# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc 
rc('text',usetex=False)
plt.rc('font', family='DejaVu Sans', size=20)

################
min=-2 
max=1
step = (max - min)/10
fonts = 15
###############
orbs=['px','py','pz','z2','x2','xy','yz','xz']
bndfile_up = 'bnd-up.dat'
bndfile_dn = 'bnd-dn.dat'
figname = "Project_both_spins.pdf"

# 设置颜色
col='cyan'
kp = ['Γ','M','K','Γ','K']

# 读取k点信息
m=open("note-bnd",'r+')
ml=m.readlines()
ml=[ml[i].strip().split() for i in range(len(ml))]
knum=int(ml[0][0])
bnum=int(ml[0][1])

base=[ml[1],ml[2],ml[3]]
base=np.array(base)
dkvec=[]
for k in range(4,len(ml)-1):
 ml[k]=[float(ml[k][j]) for j in range(3)]
for k in range(5,len(ml)-1): 
 dkvec.append((np.array(ml[k])-np.array(ml[k-1])).tolist())

def r(m,n):
 global rfinal
 global r1
 global r2
 global r3
 r1=0
 r2=0
 r3=0
 r1=[float(m[0])*float(n[0][i]) for i in range(3)]
 r2=[float(m[1])*float(n[1][i]) for i in range(3)]
 r3=[float(m[2])*float(n[2][i]) for i in range(3)]
 x=r1[0]+r2[0]+r3[0]
 y=r1[1]+r2[1]+r3[1]
 z=r1[2]+r2[2]+r3[2]
 rfinal=np.sqrt(x**2+y**2+z**2)

sum=0
k=[0 for i in range(len(ml)-6)]
for i in range(len(ml)-6):
 r(dkvec[i],base)
 k[i]=rfinal
 sum=k[i]+sum

mesh=int(ml[len(ml)-1][0])
x=[0]
a0=0
for i in range(len(ml)-6):
 for j in range(mesh):
  a0=a0+k[i]/(mesh+0.0)
  x.append(a0)

plt.figure(figsize=(20, 20))

def plt_pro(row_offset, i, orb, col, lab, spin):
    """绘制单个轨道的投影能带
    
    Parameters:
    -----------
    row_offset : int
        行偏移量，0表示spin up，4表示spin down
    i : int
        轨道索引 (1-8)
    orb : str
        轨道数据文件名
    col : str
        颜色
    lab : str
        轨道标签
    spin : str
        自旋类型 'up' 或 'dn'
    """
    # 计算子图位置：2行4列，加上行偏移
    plt.subplot(8, 4, row_offset * 4 + i)
    
    # 选择对应的能带文件
    if spin == 'up':
        bndfile = bndfile_up
        spin_color = 'red'  # spin up用红色
        spin_label = '(↑)'
    else:
        bndfile = bndfile_dn
        spin_color = 'blue'  # spin down用蓝色
        spin_label = '(↓)'
    
    # 读取能带数据
    a = np.loadtxt(bndfile)
    a.resize(knum, bnum)
    b = np.transpose(a)
    
    # 设置坐标范围
    plt.ylim(min, max)
    plt.xlim(0, sum)
    
    # 绘制费米能级线
    plt.plot([0, sum], [0, 0], 'r-.', linewidth=1)
    
    # 绘制高对称点竖线
    hline = 0
    xlab_val = [0]
    for j in range(len(ml)-6):
        hline += k[j]
        xlab_val.append(hline)
    
    hline = 0
    for j in range(len(ml)-7):
        hline += k[j]
        plt.plot([hline, hline], [min, max+step], 'b-.', linewidth=1)
    
    # 绘制能带
    for j in range(bnum):
        plt.plot(x, b[j], 'k--', linewidth=1)
    
    # 读取轨道投影数据
    a2 = np.loadtxt(orb)
    lens = len(a2)//2
    
    if spin == 'up':
        a2 = a2[0:lens]  # 前半部分是spin up
    else:
        a2 = a2[lens:]   # 后半部分是spin down
    
    a2.resize(knum, bnum)
    b2 = np.transpose(a2)
    
    # 绘制轨道投影散点
    for j in range(bnum):
        # 能带线
        plt.plot(x, b[j], 'k--', linewidth=0.5, alpha=0.3)
        # 轨道投影散点
        ax = plt.scatter(x, b[j], c=col, s=b2[j]*300, lw=0, alpha=0.7)
    
    # 设置标签
    if row_offset == 0:  # spin up行
        if i == 1:  # 第一列添加y轴标签
            plt.ylabel('Energy (eV)\nSpin Up')
        plt.title(f'{lab} {spin_label}', fontsize=16)
    else:  # spin down行
        if i == 1:  # 第一列添加y轴标签
            plt.ylabel('Energy (eV)\nSpin Down')
        plt.title(f'{lab} {spin_label}', fontsize=16)
    
    # 设置x轴刻度
    if row_offset == 7:  # 最后一行显示x轴标签
        plt.xticks(xlab_val, kp)
        plt.xlabel('k-path')
    else:
        plt.xticks(xlab_val, [])
    
    # 设置y轴刻度
    if i == 1:  # 第一列显示y轴刻度
        plt.yticks(np.arange(min, max+step, step))
    else:
        plt.yticks([])
    
    plt.tight_layout()
    ax = plt.gca()

# 绘制spin up的8个轨道
spin_up_orbs = orbs
for i, (orb, col_orb, lab) in enumerate(zip(orbs, 
                                            ["gray", "gray", "gray", "cyan", "red", "red", "blue", "blue"],
                                            [r'$p_x$', r'$p_y$', r'$p_z$', r'$d_{z^2}$', 
                                             r'$d_{x^2-y^2}$', r'$d_{xy}$', r'$d_{yz}$', r'$d_{xz}$']), 1):
    plt_pro(0, i, orb, col_orb, lab, 'up')

# 绘制spin down的8个轨道
spin_dn_orbs = orbs
for i, (orb, col_orb, lab) in enumerate(zip(orbs,
                                            ["gray", "gray", "gray", "cyan", "red", "red", "blue", "blue"],
                                            [r'$p_x$', r'$p_y$', r'$p_z$', r'$d_{z^2}$',
                                             r'$d_{x^2-y^2}$', r'$d_{xy}$', r'$d_{yz}$', r'$d_{xz}$']), 1):
    plt_pro(4, i, orb, col_orb, lab, 'dn')

plt.subplots_adjust(left=0.05, right=0.95, top=0.95, bottom=0.05, hspace=0.1, wspace=0.1)
plt.savefig(figname, format='pdf', bbox_inches='tight', dpi=300)
plt.show()

```


step6.py


```python

# -*- coding: utf-8 -*-

import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rc 
rc('text',usetex=False)
plt.rc('font', family='DejaVu Sans', size=20)

################
min=-2 
max=1
step = (max - min)/10
fonts = 15
spin = 'dn' #spin = 'up/dn/no' default value: 'up'
###############
orbs=['px','py','pz','z2','x2','xy','yz','xz']
bndfile = 'bnd-up.dat'
figname = "Project_upbnd.pdf"

if spin == 'dn':
   bndfile = 'bnd-dn.dat'
   figname ="Project_dnbnd.pdf"

if spin == 'no':
   bndfile = 'bnd-up.dat'
   figname ="Project_nospinbnd.pdf"

col='cyan'
kp = ['Γ','M','K','Γ','K']
m=open("note-bnd",'r+')
ml=m.readlines()
ml=[ml[i].strip().split() for i in range(len(ml))]
knum=int(ml[0][0])
bnum=int(ml[0][1])

base=[ml[1],ml[2],ml[3]]
base=np.array(base)
dkvec=[]
for k in range(4,len(ml)-1):
 ml[k]=[float(ml[k][j]) for j in range(3)]
for k in range(5,len(ml)-1): 
 dkvec.append((np.array(ml[k])-np.array(ml[k-1])).tolist())
def r(m,n):
 global rfinal
 global r1
 global r2
 global r3
 r1=0
 r2=0
 r3=0
 r1=[float(m[0])*float(n[0][i]) for i in range(3)]
 r2=[float(m[1])*float(n[1][i]) for i in range(3)]
 r3=[float(m[2])*float(n[2][i]) for i in range(3)]
 x=r1[0]+r2[0]+r3[0]
 y=r1[1]+r2[1]+r3[1]
 z=r1[2]+r2[2]+r3[2]
 rfinal=np.sqrt(x**2+y**2+z**2)
sum=0
k=[0 for i in range(len(ml)-6)]
for i in range(len(ml)-6):
 r(dkvec[i],base)
 k[i]=rfinal
 sum=k[i]+sum
mesh=int(ml[len(ml)-1][0])
x=[0]
a0=0
for i in range(len(ml)-6):
 for j in range(mesh):
  a0=a0+k[i]/(mesh+0.0)
  x.append(a0)

plt.figure(figsize=(20,16))

def plt_pro(i,orb,col,lab):
 plt.subplot(2,4,i)
#######up###########
 a = np.loadtxt(bndfile)
# file=open(bndfile,'r+')
# lines=file.readlines()
# a=[float(lines[i].strip()) for i in range(len(lines))]
# a=np.array(a)
 a.resize(knum,bnum)
 b=np.transpose(a)
 plt.ylim(min, max)
 plt.xlim(0,sum)
 plt.plot([0,sum],[0,0],'r-.',linewidth=1 )
 hline=0
 xlab_val = [0]
 for i in range(len(ml)-6):
  hline=hline+k[i]
  xlab_val.append(hline)
 hline=0
 for i in range(len(ml)-7):
  hline=hline+k[i]
  plt.plot([hline,hline],[min,max+step],'b-.', linewidth=1)
 for i in range(bnum):
  plt.plot(x,b[i],'k--',linewidth = 1)
 a2 = np.loadtxt(orb) 
 lens = len(a2)//2
 if spin == 'up':
  a2 = a2[0:lens]
 else:
  a2 = a2[lens:]
 a2.resize(knum,bnum)
 b2=np.transpose(a2)
 for i in range(bnum):
  ax=plt.scatter(x,b[i],c=col, s=b2[i]*300,lw=0, alpha=0.7)
  plt.legend([ax],[lab],frameon= False,fontsize = 20,loc='upper right')
###Fermi-and-high-sym-line####

 plt.ylabel('Energy (eV)')
 
 plt.xticks(xlab_val, kp)
 plt.tight_layout()
 plt.yticks(np.arange(min,max+step,step))
 ax = plt.gca()
 plt.subplots_adjust(left=0.15, right=0.9, top=0.9, bottom=0.1)
plt_pro(1,orbs[0],"gray",r'$p_x$')
plt_pro(2,orbs[1],"gray",r'$p_y$')
plt_pro(3,orbs[2],"gray",r'$p_z$')
plt_pro(4,orbs[3],"cyan",r'$d_{z^2}$')
plt_pro(5,orbs[4],"red",r'$d_{x^2-y^2}$')
plt_pro(6,orbs[5],"red",r'$d_{xy}$')
plt_pro(7,orbs[6],"blue",r'$d_{yz}$')
plt_pro(8,orbs[7],"blue",r'$d_{xz}$')
plt.subplots_adjust(wspace =0.25, hspace =0.1)
plt.savefig(figname,format='pdf', bbox_inches='tight', dpi=300)


```