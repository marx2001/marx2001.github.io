---
layout: post
title: "vasp计算投影能带"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20250924-pbands/
---

## <center>Vasp计算DOS</center>

　　投影能带的计算不是必需的，而是在分析机制的时候使用。例如在分析晶体场劈裂情况时需要用到。使用名称为《vasp计算能带》文章中所用的INCAR，计算完成后，输入vaspkit/214 即可输出手动选择特定原子的投影能带数据文件。下面是vaspkit投影能带的选取注释：

211    标准能带结构（包含所有原子和轨道的投影）

212    仅提取单个选定原子的轨道投影能带

213    按元素分类（如所有 Fe 原子）的投影能带

214    手动选择特定原子（输入原子序号）的投影能带

215    按元素权重（如 50% Fe + 50% O）的投影能带

216    对选定原子和轨道的投影求和（如所有 Fe 的 d 轨道）


**<span style="font-size: 120%"> 1.Origin绘图（重点）</span>**

以MPSS为例，其结构如图所示

<div align="center"><img src="/img/vasp计算能带/bg-s1.png" alt="MPSS结构图" style="width:500px; height:auto;"/></div>
<div align="center"><img src="/img/vasp计算能带/bg-s2.png" alt="MPSS结构图" style="width:500px; height:auto;"/></div>

vaspkit/214/Mo，绘制Mo原子的投影能带

<div align="center"><img src="/img/vasp计算投影能带/bg-b1.png" alt="第一步" style="width:500px; height:auto;"/></div>

如上图所示，得到数据文件PBAND_SUM_DW.dat和PBAND_SUM_UP.dat文件。删除上图中选中的两行，便于在origin中直接作为标签。

如下图所示，直接将数据文件拖到origin中：

<div align="center"><img src="/img/vasp计算投影能带/bg-b2.png" alt="第一步" style="width:500px; height:auto;"/></div>

选中如图所示两行画图，如下图所示
<div align="center"><img src="/img/vasp计算投影能带/bg-b3.png" alt="b3" style="width:500px; height:auto;"/></div>

双击1，进入图层，选中十个新添加的图层，点击2成组，点击3，修改成散点图

<div align="center"><img src="/img/vasp计算投影能带/bg-b4.png" alt="b3" style="width:500px; height:auto;"/></div>

双击图像（红框区域），弹出来对话框

<div align="center"><img src="/img/vasp计算投影能带/bg-b5.png" alt="b3" style="width:500px; height:auto;"/></div>

修改如下图所示的三个参数，缩放因子建议20。

<div align="center"><img src="/img/vasp计算投影能带/bg-b6.png" alt="b3" style="width:500px; height:auto;"/></div>

注意事项——反铁磁基态，可以任意选择能量折线图，而铁磁基态，由于能带spin up和spin down不简并，所以绘图时要注意，Energy折线图up要选5个（d轨道，p轨道选3个），down要选五个。

原因是投影能带是算的每个轨道相比于Energy的权重，而反铁磁基态的能量是简并的，所以选up和down的均可，不影响权重计算，而铁磁基态由于作为分母的总能量不简并，所以若想准确计算权重，能量折线图（分母）必须一半up一半down。

最终效果图：

<div align="center"><img src="/img/vasp计算投影能带/bg-b7.png" alt="b3" style="width:500px; height:auto;"/></div>


**<span style="font-size: 120%"> 2.自定义脚本绘图（原创）</span>**

这是一个功能强大的，方便自定义任何参数的，类似于vaspkit的脚本，首先要求你的目录结构如下：

```python
你的工作目录/
├── bands/                    # 能带计算目录 (当前运行脚本的目录)
│   ├── KPOINTS              # 能带路径文件 (包含高对称点)
│   ├── POSCAR -> ../POSCAR  # [推荐] 链接到结构文件
│   ├── POTCAR -> ../POTCAR  # [推荐] 链接到赝势文件
│   ├── INCAR                # 能带计算INCAR (ICHARG=11)
│   ├── vasprun.xml          # 能带计算输出
│   ├── PROCAR               # 能带计算投影输出
│   └── plot_fatbands.py     # 脚本文件 (在这里运行)
│
├── dos/                     # DOS计算目录
│   ├── KPOINTS             # DOS K点文件 (通常更密集)
│   ├── POSCAR -> ../POSCAR
│   ├── POTCAR -> ../POTCAR
│   ├── INCAR               # DOS计算INCAR (LORBIT=11)
│   └── vasprun.xml         # DOS计算输出
│
├── POSCAR                  # 晶体结构文件
└── POTCAR                  # 赝势文件 (由所有原子的POTCAR拼接)

```

自旋极化的投影能带绘制，代码如下：

```python

import numpy as np
import math
import pymatgen
import sys
import argparse
import logging
import time

from pymatgen.io.vasp.outputs import Procar, Vasprun
from pymatgen.io.vasp.inputs import Kpoints
from pymatgen.core import Structure
from pymatgen.electronic_structure.core import Spin, Orbital

import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
from matplotlib.gridspec import GridSpec

# 添加tqdm导入
try:
    from tqdm import tqdm
except ImportError:
    # 如果tqdm不可用，创建空实现
    def tqdm(iterable, **kwargs):
        return iterable

class SaneFormatter(argparse.RawTextHelpFormatter, 
                    argparse.ArgumentDefaultsHelpFormatter):
    pass

parser = argparse.ArgumentParser(prog='plot_fatbands.py',description=("Plot projected band structure (fatbands) from a VASP calculation.\n" +
                                    'Author: Marco Cappelletti. Heavily inspired by Kevin Waters (kwaters4.github.io) and sumo-bandplot.\n' +
                                    'By default is assumes that:\n'  +
                                    '\tthe current directory contains KPOINTS, vasprun.xml from the band calculations\n' +
                                    '\tthe directory ../dos contains vasprun.xml from the dos calculation\n' +
                                    '\tthe parent directory (../) contains the POSCAR file\n' +
                                    '\tthe parent parent directory (../../) contains the POTCAR file\n')
                                    ,formatter_class=SaneFormatter)
parser.add_argument('-b','--vasprun-file-bands', type=str, help='Path of the vasprun.xml file of the band calculation', default='vasprun.xml')
parser.add_argument('-K','--KPOINTS-file', type=str, help='Path of the KPOINTS file with the band path', default='KPOINTS')
parser.add_argument('-c','--POSCAR-file', type=str, help='Path of the POSCAR file', default='../POSCAR')
parser.add_argument('-O','--PROCAR-file', type=str, help='Path of the PROCAR file from the band calculation', default='PROCAR')
parser.add_argument('-w','--POTCAR-file', type=str, help='Path of the POTCAR file', default='../../POTCAR')
parser.add_argument('-d','--vasprun-file-dos', type=str, help='Path of the vasprun.xml file of the dos calculation', default='../dos/vasprun.xml')
parser.add_argument('-p','--project', help='Band projection to rgb. Either 2 (red and green) or 3 arguments (red, green, blue). Nomenclature:\n'
                                                    '\t- E: all orbitals of element E (H, C, N, O, ...)\n'
                                                    '\t- E.o: o-orbital of element E (s, px, py, pz, dxy, ...)\n'
                                                    '\t- E.s.pz: s+pz orbitals of element E\n'
                                                    '\t- X.s: s orbitals of all elements\n'
                                                    '\t- O.s.pz+N.pz: sum of O(s,pz) and N(pz)\n', nargs='+', default=['X.px', 'X.py', 'X.s.pz'])
parser.add_argument('-n','--normalization', type=str, help=f'Normalization of the projection.\n'
                                                    '\t-\'all\': with respect to all contributions.\n'
                                                    '\t-\'selection\': with respect to selection only\n', choices=['all','selection'], default='selection')
parser.add_argument('-l','--max-l',type=int,default=1,choices=[1,2,3],help='Maximum value of l (angular momemtum) for the projection. Increases computational costs, so increase it only if necessary.')
parser.add_argument('-e','--emin', type=float, help='Minimum of energy in the plot. If none, it chooses the lower limit', default=None)
parser.add_argument('-E','--emax', type=float, help='Maximum of energy in the plot. If none, it chooses the upper limit', default=None)
parser.add_argument('-s','--scale', type=float, help='DOS scale factor', default=2.0)
parser.add_argument('-H','--height', type=float, help='Height of the plot in inches', default=3.5)
parser.add_argument('-W','--width', type=float, help='Width of the plot in inches', default=3.3)
parser.add_argument('-r','--ratio', type=float, help='Bandplot - dosplot width ratio', default=3.0)
parser.add_argument('-f','--font-size', type=float, help='Fontsize', default=8)
parser.add_argument('-o','--output-file', type=str, help='Path and name of the output file, excluding the format', default='fatbands')
parser.add_argument('--format', type=str, help='Output file format', choices=['pdf','png'], default='pdf')
# 添加轨道气泡图参数
parser.add_argument('--element', type=str, help='Element for orbital bubble plot (e.g., Fe)', default=None)
parser.add_argument('--orbital-type', type=str, choices=['d', 'p'], help='Type of orbital to plot (d or p)', default='d')
parser.add_argument('--bubble-min', type=float, help='Minimum bubble size', default=0.05)
parser.add_argument('--bubble-max', type=float, help='Maximum bubble size', default=0.3)
parser.add_argument('--bubble-scale', type=float, help='Bubble size scaling factor', default=100)
parser.add_argument('--bubble-density', type=int, help='Bubble density (1: every point, 2: every second point, etc.)', default=5)
parser.add_argument('--bubble-threshold', type=float, help='Minimum weight to plot bubble', default=0.05)

args = parser.parse_args()
scale=args.scale

logging.basicConfig(
    filename="plot_fatbands.log",
    level=logging.INFO,
    filemode="w",
    format="%(message)s",
)

logging.info(" ".join(sys.argv[:]))

# plot colored line. Function written by Kevin Waters
def rgbline(ax, k, e, red, green, blue, KPOINTS, alpha=1.):
    #creation of segments based on
    #http://nbviewer.ipython.org/urls/raw.github.com/dpsanders/matplotlib-examples/master/colorline.ipynb
    pts = np.array([KPOINTS, e]).T.reshape(-1, 1, 2)
    seg = np.concatenate([pts[:-1], pts[1:]], axis=1)
    nseg = len(KPOINTS) -1
    a = np.ones(nseg, np.float64)*alpha
    lc = LineCollection(seg, colors=list(zip(red,green,blue,a)), linewidth = 2)
    ax.add_collection(lc)


if __name__ == "__main__":
    # Load Structure
    structure = Structure.from_file(args.POSCAR_file)
    atom_labels = structure.labels
    # Load Band Structure Calculations
    bands = Vasprun(args.vasprun_file_bands,parse_potcar_file=args.POTCAR_file).get_band_structure(args.KPOINTS_file, line_mode = True)
    # Read KPOINTS file with path
    kpts = Kpoints.from_file(args.KPOINTS_file)  

    # projected bands - get both spin up and spin down data
    procar = Procar(args.PROCAR_file)
    data_up = procar.data[Spin.up]
    data_down = procar.data[Spin.down] if Spin.down in procar.data else None
    
    # density of states
    dosrun = Vasprun(args.vasprun_file_dos,parse_potcar_file=args.POTCAR_file)

    # k-point labels
    n_labels = len(kpts.labels)
    labels = []
    labels.append(kpts.labels[0])
    for label_idx in range(1,n_labels,2):
        labels.append(kpts.labels[label_idx])
    
    # Number of points between kpoints, found in the KPOINTS file
    step = kpts.num_kpts


    # general options for plot
    font = {'family': 'serif', 'size': args.font_size}
    plt.rc('font', **font)

    # set up 2 graph with aspec ratio args.ratio/1
    # plot 1: bands diagram
    # plot 2: DOS
    gs = GridSpec(1, 2, width_ratios=[args.ratio,1], wspace=0.1)
    fig = plt.figure(figsize=(args.width, args.height))
    ax1 = plt.subplot(gs[0])
    ax2 = plt.subplot(gs[1]) #, sharey=ax1)

    # Set both fermi levels equal to the band fermi level
    bands.efermi =  dosrun.efermi #= 0

    # set y limits for the plot
    emin = args.emin
    emax = args.emax

    # if either is not defined
    if emin is None and emax is None:
        emin=100
        emax=-100
        for spin in bands.bands.keys():
            for b in range(bands.nb_bands):
                emin = min(emin, min(bands.bands[spin][b]))
                emax = max(emax, max(bands.bands[spin][b]))
    elif emin is None:
        emin=100
        for spin in bands.bands.keys():
            for b in range(bands.nb_bands):
                emin = min(emin, min(bands.bands[spin][b]))
    elif emax is None:
        emax=-100
        for spin in bands.bands.keys():
            for b in range(bands.nb_bands):
                emax = max(emax, max(bands.bands[spin][b]))
    
    ax1.set_ylim(emin, emax)
    ax2.set_ylim(emin, emax)

    # 检测是否需要绘制投影能带
    draw_projected_bands = True
    if args.element:
        print(f"Orbital bubble plot enabled for {args.element} {args.orbital_type}-orbitals")
        draw_projected_bands = False  # 当指定元素和轨道类型时，不绘制投影能带

    # accepts only 2 or 3 entries for the projection
    if len(args.project) != 2 and len(args.project) != 3 and draw_projected_bands:
        raise ValueError('Either 2 or 3 components for the projection')

    # 定义轨道类型
    orbital_values = { 
        's': 0, 
        'py': 1, 'pz': 2, 'px': 3, 
        'dxy': 4, 'dyz': 5, 'dz2': 6, 'dxz': 7, 'dx2_y2': 8, 
        'f_3' : 9, 'f_2' : 10, 'f_1' : 11, 'f0' : 12, 'f1' : 13, 'f2' : 14, 'f3' : 15 
    }
    
    # ===== 新增：自动检测所需的轨道类型 =====
    # 定义轨道名称到角动量l的映射
    orbital_to_l = {
        's': 0,
        'p': 1, 'px':1, 'py':1, 'pz':1,
        'd': 2, 'dxy':2, 'dyz':2, 'dz2':2, 'dxz':2, 'dx2_y2':2,
        'f': 3, 'f_3':3, 'f_2':3, 'f_1':3, 'f0':3, 'f1':3, 'f2':3, 'f3':3
    }

    # 保存原始的max_l
    original_max_l = args.max_l

    # 如果用户没有指定--max-l（即使用默认值1），则检查投影参数
    if original_max_l == 1:  # 默认值
        max_required_l = 1
        for component in args.project:
            # 分割投影字符串
            element_components = component.split("+")
            for element_component in element_components:
                splits = element_component.split(".")
                if len(splits) > 1:
                    orbitals = splits[1:]
                    for orb in orbitals:
                        # 如果轨道在映射中，则获取l值
                        if orb in orbital_to_l:
                            l_val = orbital_to_l[orb]
                            if l_val > max_required_l:
                                max_required_l = l_val
        # 更新max_l
        args.max_l = max_required_l

    # 如果max_l被调整了，记录日志
    if original_max_l != args.max_l:
        logging.info(f"Automatically adjusted max_l from {original_max_l} to {args.max_l} based on projection")
        print(f"Automatically adjusted max_l from {original_max_l} to {args.max_l} based on projection")
    # ===== 新增结束 =====

    max_l_index = (args.max_l + 1)**2   # 1 -> 4, 2 -> 9, 3 -> 16. So to have range(0,max_l_index) = [0,1,...,max_l_index-1]
    
    # 定义p轨道
    p_orbitals = ['px', 'py', 'pz']
    p_orbital_indices = [orbital_values[o] for o in p_orbitals]
    
    # 定义d轨道
    d_orbitals = ['dxy', 'dyz', 'dz2', 'dxz', 'dx2_y2']
    d_orbital_indices = [orbital_values[o] for o in d_orbitals]
    
    # 定义轨道的形状和颜色（空心）
    orbital_markers = {
        'dxy': ('s', 'black'),      # 黑色正方形（空心）
        'dxz': ('o', 'red'),        # 红色圆形（空心）
        'dyz': ('^', 'green'),      # 绿色正三角形（空心）
        'dz2': ('v', 'blue'),       # 蓝色倒三角形（空心）
        'dx2_y2': ('D', 'cyan'),    # 天蓝色菱形（空心）
        'px': ('o', 'red'),         # 红色圆形（空心）
        'py': ('s', 'green'),       # 绿色正方形（空心）
        'pz': ('^', 'blue')         # 蓝色正三角形（空心）
    }

    # 根据轨道类型选择要绘制的轨道
    if args.orbital_type == 'd':
        orbitals_to_plot = d_orbitals
        orbital_indices = d_orbital_indices
    elif args.orbital_type == 'p':
        orbitals_to_plot = p_orbitals
        orbital_indices = p_orbital_indices
    else:
        orbitals_to_plot = []
        orbital_indices = []

    # 只有当需要绘制投影能带时才计算投影贡献
    if draw_projected_bands:
        # calculates contributions for bands and DOS projections
        el_orbs = []
        el_orbs_labels = []
        for component in args.project:         # either 2 or 3 components, e.g. 'N.s.pz', 'N.s+O.s.pz', 'N.s', 'N+O', 'X', 'X.s', 'X.s+N.px.py.pz', ...
            element_components = component.split("+")   # split elements, e.g. 'N.s+O.s.pz' becomes ['N.s', 'O.s.pz']
            color_component = []
            label_text = []
            for element_component in element_components:
                splits = element_component.split(".")     # e.g. 'N.s.pz' converted to ['N', 's', 'pz']
                element = splits[0]                       # first element is the atom symbol
                if len(splits) == 1:                    # if no orbital is specified (e.g. 'N'), then plot all orbitals (= 'all')
                    orbitals = 'all'
                else:
                    orbitals = splits[1:]               # e.g. ['s', 'pz'] 
                color_component.append([element,orbitals])

                # write text for legend
                if element == 'X':                      # 'X' represents all atoms
                    if len(splits) == 1:
                        label_text.append('s+p_x+p_y+p_z')       # this makes no sense, it's the projection of all atoms and orbitals, put who am I to judge
                    else:
                        label_text.append("+".join(orbitals).replace('p','p_'))   # e.g. 'X.s.pz' becomes 's+p_z'
                else:
                    if len(splits) == 1:                     # all orbitals, only the element: 'N'
                        label_text.append(element)
                    else:
                        label_text.append(f"{element}({','.join(orbitals).replace('p','p_')})")   # e.g. 'O.s.pz' becomes 'O(s+p_z)'
            el_orbs.append(color_component)
            el_orbs_labels.append("+".join(label_text))           # e.g. 'O.s.pz+H.s' becomes 'O(s+p_z)+H(s)'


        color_values = { 0: 'red', 1: 'green', 2: 'blue' }        
        print('projections:')
        for color_idx, color_contrib in enumerate(el_orbs_labels):
            print(f'color {color_values[color_idx]}: {color_contrib}')

        # contributions to the band per each band, k-point, and color: contrib_bands[spin][band][k-point][color]
        contrib_bands = {
            Spin.up: np.zeros((bands.nb_bands, len(bands.kpoints), 3))
        }
        if data_down is not None:
            contrib_bands[Spin.down] = np.zeros((bands.nb_bands, len(bands.kpoints), 3))

        # 检测自旋极化DOS计算
        has_spin_down_dos = (Spin.down in dosrun.pdos[0][Orbital.s])  # 检测是否存在自旋向下分量

        # 初始化contrib_dos，分别存储自旋向上和自旋向下（如果存在）
        contrib_dos = {
            Spin.up: np.zeros((len(el_orbs), len(dosrun.tdos.energies))),
        }
        if has_spin_down_dos:
            contrib_dos[Spin.down] = np.zeros((len(el_orbs), len(dosrun.tdos.energies)))
        else:
            contrib_dos[Spin.down] = None

        # 添加进度条 - 计算投影贡献
        print("\nCalculating projections:")
        for spin in [Spin.up, Spin.down]:
            if spin not in contrib_bands:
                continue
                
            # 创建进度条
            spin_name = "up" if spin == Spin.up else "down"
            band_range = tqdm(range(bands.nb_bands), 
                              desc=f"Processing {spin_name} bands", 
                              total=bands.nb_bands,
                              leave=True)
            
            # sum over all bands
            for b in band_range:
                # sum over all k-points
                for k in range(len(bands.kpoints)):
                    for color_idx, color_contrib in enumerate(el_orbs): # color_idx: up to either 2 or 3. color_contrib: list of [elements, orbitals] for each color
                        for element_contrib in color_contrib:
                            element = element_contrib[0]     # e.g. 'X', 'N'
                            orbitals = element_contrib[1]        # e.g. 'all', 's', ['s', 'pz']
                            if element == 'X':                   # if all atoms, get all indexes
                                element_indexes = range(len(atom_labels))
                            else:                               # else, get the indexes with label = atom symbol (e.g. 'C')
                                element_indexes = [i for i, x in enumerate(atom_labels) if x == element]

                            if orbitals == 'all':
                                orbital_indexes = range(0,max_l_index)   # sum all orbitals if 'all'
                            else:
                                orbital_indexes = [orbital_values[o] for o in orbitals]
                                
                            for i in element_indexes:
                                for j in orbital_indexes:
                                    if spin == Spin.up:
                                        contrib_bands[spin][b,k,color_idx] += data_up[k][b][i][j]**2
                                    else:  # spin down
                                        contrib_bands[spin][b,k,color_idx] += data_down[k][b][i][j]**2
                                    
                                    # Only need to add to DOS once (using spin up)
                                    if spin == Spin.up and k == 0 and b == 0:
                                        contrib_dos[Spin.up][color_idx] += np.array(dosrun.pdos[i][Orbital(j)][Spin.up])
                                        if has_spin_down_dos:
                                            contrib_dos[Spin.down][color_idx] += np.array(dosrun.pdos[i][Orbital(j)][Spin.down])

                    # normalization
                    if args.normalization == 'selection':
                        if np.sum(contrib_bands[spin][b,k,:]) != 0:
                            contrib_bands[spin][b,k,:] = contrib_bands[spin][b,k,:]/np.sum(contrib_bands[spin][b,k,:])
                    elif args.normalization == 'all':
                        tot = 0.0
                        for i in range(len(atom_labels)):
                            for j in range(0,max_l_index):
                                if spin == Spin.up:
                                    tot += data_up[k][b][i][j]**2
                                else:
                                    tot += data_down[k][b][i][j]**2
                        if tot != 0:
                            contrib_bands[spin][b,k,:] = contrib_bands[spin][b,k,:]/tot   

    # 添加进度条 - 计算轨道权重
    weights = {}
    if args.element:
        print(f"\nCalculating {args.orbital_type}-orbital weights for {args.element}:")
        weights = {
            Spin.up: {orb: np.zeros((bands.nb_bands, len(bands.kpoints))) for orb in orbitals_to_plot},
            Spin.down: {orb: np.zeros((bands.nb_bands, len(bands.kpoints))) for orb in orbitals_to_plot}
        }
        
        # 获取特定元素的原子索引
        element_indexes = [i for i, x in enumerate(atom_labels) if x == args.element]
        if not element_indexes:
            raise ValueError(f"No atoms of element {args.element} found in the structure")
            
        for spin in [Spin.up, Spin.down]:
            if spin == Spin.down and data_down is None:
                continue
                
            # 创建进度条
            spin_name = "up" if spin == Spin.up else "down"
            band_range = tqdm(range(bands.nb_bands), 
                              desc=f"Processing {spin_name} weights", 
                              total=bands.nb_bands,
                              leave=True)
            
            for b in band_range:
                for k in range(len(bands.kpoints)):
                    # 计算该元素所有指定轨道的总贡献
                    total = 0.0
                    for i in element_indexes:
                        for j in orbital_indices:
                            if spin == Spin.up:
                                total += data_up[k][b][i][j]**2
                            else:
                                total += data_down[k][b][i][j]**2
                    
                    # 计算每个轨道的权重
                    for orb in orbitals_to_plot:
                        j = orbital_values[orb]
                        orb_value = 0.0
                        for i in element_indexes:
                            if spin == Spin.up:
                                orb_value += data_up[k][b][i][j]**2
                            else:
                                orb_value += data_down[k][b][i][j]**2
                        
                        if total > 1e-6:  # 避免除以零
                            weight = orb_value / total
                        else:
                            weight = 0.0
                        
                        weights[spin][orb][b, k] = weight

    reciprocal = bands.lattice_rec.matrix/(2*math.pi)

    # unchanged from Kevin Waters
    # Empty lists used for caculating the distances between K-Points
    KPOINTS = [0.0]
    DIST = 0.0
    # Create list with distances between Kpoints (Individual), corrects the spacing
    for k in range(len(bands.kpoints)-1 ):
        Dist = np.subtract(bands.kpoints[k+1].frac_coords,bands.kpoints[k].frac_coords)
        DIST += np.linalg.norm(np.dot(reciprocal,Dist))
        KPOINTS.append(DIST)

    # 只有当需要绘制投影能带时才绘制彩色能带
    if draw_projected_bands:
        print("Plotting projected bands...")
        for spin in [Spin.up, Spin.down]:
            if spin not in contrib_bands:
                continue
                
            for b in range(bands.nb_bands):
                rgbline(ax1,
                        range(len(bands.kpoints)),
                        [e - bands.efermi for e in bands.bands[spin][b]],
                        contrib_bands[spin][b,:,0],
                        contrib_bands[spin][b,:,1],
                        contrib_bands[spin][b,:,2] if len(args.project) == 3 else np.zeros(len(bands.kpoints)),     # 如果只有两个颜色，第三个分量设为零
                        KPOINTS=KPOINTS)
    else:
        # 绘制简单的能带图（灰色）
        print("Plotting simple bands...")
        for spin in [Spin.up, Spin.down]:
            if spin not in bands.bands:
                continue
                
            for b in range(bands.nb_bands):
                ax1.plot(KPOINTS, [e - bands.efermi for e in bands.bands[spin][b]], 
                         color='gray', alpha=0.5, linewidth=0.8)

    # 优化后的轨道气泡图绘制（空心气泡）
    if args.element:
        print(f"Plotting {args.orbital_type}-orbital bubbles...")
        # 计算气泡大小范围
        min_size = args.bubble_min * args.bubble_scale
        max_size = args.bubble_max * args.bubble_scale
        
        # 为每个轨道绘制气泡（空心）
        for spin in [Spin.up, Spin.down]:
            if spin not in weights:
                continue
                
            for orb in orbitals_to_plot:
                marker, color = orbital_markers[orb]
                # 收集所有点一次性绘制
                x_vals = []
                y_vals = []
                sizes = []
                
                # 使用步长减少点数
                k_step = args.bubble_density
                b_step = args.bubble_density
                
                # 创建进度条
                total_points = (bands.nb_bands // b_step) * (len(bands.kpoints) // k_step)
                if total_points > 0:
                    progress = tqdm(total=total_points,
                                    desc=f"{orb} bubbles",
                                    unit="point")
                else:
                    progress = None
                
                for b in range(0, bands.nb_bands, b_step):
                    for k in range(0, len(bands.kpoints), k_step):
                        weight = weights[spin][orb][b, k]
                        
                        # 只绘制权重大于阈值的点
                        if weight > args.bubble_threshold:
                            # 计算气泡大小（与权重成正比）
                            size = min_size + weight * (max_size - min_size)
                            
                            # 获取能量值
                            energy = bands.bands[spin][b][k] - bands.efermi
                            
                            # 添加点
                            x_vals.append(KPOINTS[k])
                            y_vals.append(energy)
                            sizes.append(size)
                            
                        if progress:
                            progress.update(1)
                
                # 一次性绘制该轨道的所有点（空心）
                if x_vals:  # 确保列表不为空
                    ax1.scatter(
                        x_vals, 
                        y_vals,
                        s=sizes,
                        marker=marker,
                        facecolors='none',  # 空心
                        edgecolors=color,   # 边框颜色
                        linewidths=0.4,     # 边框线宽
                        alpha=0.4,          # 稍微降低透明度
                        zorder=10           # 确保气泡在能带上方
                    )
                
                if progress:
                    progress.close()
        
        # 创建图例（只包含轨道气泡）
        legend_handles = []
        for orb in orbitals_to_plot:
            marker, color = orbital_markers[orb]
            legend_handles.append(
                plt.Line2D([0], [0], 
                            marker=marker, 
                            color=color, 
                            markerfacecolor='none',  # 空心
                            markeredgecolor=color,
                            markersize=8, 
                            linestyle='None',
                            label=f"{orb}")
            )
        
        # 在右侧的ax2上绘制图例（DOS位置）
        ax2.clear()  # 清除原有内容
        ax2.axis('off')  # 关闭坐标轴
        
        # 创建图例并放置在右侧中央位置
        ax2.legend(handles=legend_handles, 
               loc='center',  # 中心位置
               bbox_to_anchor=(0.57, 0.81),  # 精确中心位置
               fancybox=False, 
               shadow=False, 
               prop={'size': args.font_size},
               framealpha=0.8,
               title=f"{args.element} {args.orbital_type}-orbitals",
               title_fontsize=args.font_size)
        
        # 调整标题位置
        ax1.set_title(f"{args.element} {args.orbital_type}-orbitals", 
                     fontsize=args.font_size, pad=10,y=1.05)
        # 调整右侧子图位置，使图例更靠近能带图
        plt.subplots_adjust(right=0.85)  # 增加右侧空白区域

    # style
    ax1.set_ylabel(r"$E - E_f$ (eV)",labelpad=-2)     #labelpad might work bad
    ax1.grid()

    # fermi level line at 0
    ax1.hlines(y=0, xmin=0, xmax=len(bands.kpoints), color="k", lw=2)

    TICKS = [0.0]
    for i in range(step,len(KPOINTS)+step,step):
        ax1.vlines(KPOINTS[i-1], emin, emax, "k")
        TICKS.append(KPOINTS[i-1])
    ax1.set_xticks(TICKS)
    ax1.set_xticklabels(labels)
    ax1.tick_params(axis='x', which='both', length=0, pad=5)
    ax1.set_xlim(0, KPOINTS[-1])


    # 只有当需要绘制投影能带时才绘制DOS
    if draw_projected_bands:
        print("Plotting DOS...")
        # 绘制总DOS
        if has_spin_down_dos:
            # 自旋向上（正方向）
            ax2.plot(dosrun.tdos.densities[Spin.up], dosrun.tdos.energies - dosrun.efermi,
                     color=(0.6, 0.6, 0.6), label="total up", lw=1)
            # 自旋向下（负方向）
            ax2.plot(-dosrun.tdos.densities[Spin.down], dosrun.tdos.energies - dosrun.efermi,
                     color=(0.6, 0.6, 0.6), label="total down", lw=1)
            # 填充区域
            ax2.fill_betweenx(dosrun.tdos.energies - dosrun.efermi,
                             0, dosrun.tdos.densities[Spin.up],
                             color=(0.7, 0.7, 0.7), facecolor=(0.7, 0.7, 0.7))
            ax2.fill_betweenx(dosrun.tdos.energies - dosrun.efermi,
                             0, -dosrun.tdos.densities[Spin.down],
                             color=(0.7, 0.7, 0.7), facecolor=(0.7, 0.7, 0.7))
            # 计算最大DOS值（考虑两个自旋方向）
            maxdos = max(np.max(dosrun.tdos.densities[Spin.up]), 
                         np.max(dosrun.tdos.densities[Spin.down])) / scale
        else:
            # 非自旋极化计算
            ax2.plot(dosrun.tdos.densities[Spin.up], dosrun.tdos.energies - dosrun.efermi,
                     color=(0.6, 0.6, 0.6), label="total", lw=1)
            ax2.fill_betweenx(dosrun.tdos.energies - dosrun.efermi,
                             0, dosrun.tdos.densities[Spin.up],
                             color=(0.7, 0.7, 0.7), facecolor=(0.7, 0.7, 0.7))
            maxdos = np.max(dosrun.tdos.densities[Spin.up]) / scale

        # 绘制投影DOS（自旋向上）
        ax2.plot(contrib_dos[Spin.up][0], dosrun.tdos.energies - dosrun.efermi,
                 c=(1.0, 0.0, 0.0), label=f'${el_orbs_labels[0]}$', linewidth=1)
        ax2.plot(contrib_dos[Spin.up][1], dosrun.tdos.energies - dosrun.efermi,
                 c=(0.0, 1.0, 0.0), label=f'${el_orbs_labels[1]}$', linewidth=1)

        # 如果有自旋向下分量，绘制负方向的投影
        if has_spin_down_dos:
            ax2.plot(-contrib_dos[Spin.down][0], dosrun.tdos.energies - dosrun.efermi,
                     c=(1.0, 0.0, 0.0), linewidth=1)
            ax2.plot(-contrib_dos[Spin.down][1], dosrun.tdos.energies - dosrun.efermi,
                     c=(0.0, 1.0, 0.0), linewidth=1)

        # 如果有第三个颜色分量
        if len(el_orbs) == 3:
            ax2.plot(contrib_dos[Spin.up][2], dosrun.tdos.energies - dosrun.efermi,
                     c=(0.0, 0.0, 1.0), label=f'${el_orbs_labels[2]}$', linewidth=1)
            if has_spin_down_dos:
                ax2.plot(-contrib_dos[Spin.down][2], dosrun.tdos.energies - dosrun.efermi,
                         c=(0.0, 0.0, 1.0), linewidth=1)

        # 调整x轴范围
        if has_spin_down_dos:
            ax2.set_xlim(-maxdos, maxdos)
        else:
            ax2.set_xlim(0, maxdos)

        # 添加y=0的水平线
        ax2.hlines(y=0, xmin=ax2.get_xlim()[0], xmax=ax2.get_xlim()[1], color="k", lw=2)

        # 添加x=0的垂直线（仅当有自旋向下分量时）
        if has_spin_down_dos:
            ax2.vlines(x=0, ymin=emin, ymax=emax, color="k", lw=1, linestyle='--', alpha=0.5)

        ax2.set_yticklabels([])
        ax2.grid()
        ax2.set_xticks([])
        ax2.set_xlabel("DOS")
        ax2.legend(fancybox=False, shadow=False, prop={'size': args.font_size-1}, 
                   labelspacing=0.15, borderpad=0.20, handlelength=1.2, 
                   framealpha=0.6, loc='upper right')

    # Plotting 
    # -----------------
    print("Saving plot...")
    plt.savefig(f"{args.output_file}.{args.format}", format=args.format, bbox_inches='tight')
    print("Done!")
```

Usage
```python

usage: plot_fatbands.py [-h] [-b VASPRUN_FILE_BANDS] [-K KPOINTS_FILE] [-c POSCAR_FILE] [-O PROCAR_FILE] [-w POTCAR_FILE] [-d VASPRUN_FILE_DOS] [-p PROJECT [PROJECT ...]]
                        [-n {all,selection}] [-l {1,2,3}] [-e EMIN] [-E EMAX] [-s SCALE] [-H HEIGHT] [-W WIDTH] [-r RATIO] [-f FONT_SIZE] [-o OUTPUT_FILE] [--format {pdf,png}]
                        [--element ELEMENT] [--orbital-type {d,p,f}] [--bubble-min BUBBLE_MIN] [--bubble-max BUBBLE_MAX] [--bubble-scale BUBBLE_SCALE] [--bubble-density BUBBLE_DENSITY]
                        [--bubble-threshold BUBBLE_THRESHOLD]

Plot projected band structure (fatbands) from a VASP calculation.
Author: Marco Cappelletti. Heavily inspired by Kevin Waters (kwaters4.github.io) and sumo-bandplot.
By default is assumes that:
	the current directory contains KPOINTS, vasprun.xml from the band calculations
	the directory ../dos contains vasprun.xml from the dos calculation
	the parent directory (../) contains the POSCAR file
	the parent parent directory (../../) contains the POTCAR file

optional arguments:
  -h, --help            show this help message and exit
  -b VASPRUN_FILE_BANDS, --vasprun-file-bands VASPRUN_FILE_BANDS
                        Path of the vasprun.xml file of the band calculation (default: vasprun.xml)
  -K KPOINTS_FILE, --KPOINTS-file KPOINTS_FILE
                        Path of the KPOINTS file with the band path (default: KPOINTS)
  -c POSCAR_FILE, --POSCAR-file POSCAR_FILE
                        Path of the POSCAR file (default: ../POSCAR)
  -O PROCAR_FILE, --PROCAR-file PROCAR_FILE
                        Path of the PROCAR file from the band calculation (default: PROCAR)
  -w POTCAR_FILE, --POTCAR-file POTCAR_FILE
                        Path of the POTCAR file (default: ../../POTCAR)
  -d VASPRUN_FILE_DOS, --vasprun-file-dos VASPRUN_FILE_DOS
                        Path of the vasprun.xml file of the dos calculation (default: ../dos/vasprun.xml)
  -p PROJECT [PROJECT ...], --project PROJECT [PROJECT ...]
                        Band projection to rgb. Either 2 (red and green) or 3 arguments (red, green, blue). Nomenclature:
                        	- E: all orbitals of element E (H, C, N, O, ...)
                        	- E.o: o-orbital of element E (s, px, py, pz, dxy, ...)
                        	- E.s.pz: s+pz orbitals of element E
                        	- X.s: s orbitals of all elements
                        	- O.s.pz+N.pz: sum of O(s,pz) and N(pz)
                         (default: ['X.px', 'X.py', 'X.s.pz'])
  -n {all,selection}, --normalization {all,selection}
                        Normalization of the projection.
                        	-'all': with respect to all contributions.
                        	-'selection': with respect to selection only
                         (default: selection)
  -l {1,2,3}, --max-l {1,2,3}
                        Maximum value of l (angular momemtum) for the projection. Increases computational costs, so increase it only if necessary. (default: 1)
  -e EMIN, --emin EMIN  Minimum of energy in the plot. If none, it chooses the lower limit (default: None)
  -E EMAX, --emax EMAX  Maximum of energy in the plot. If none, it chooses the upper limit (default: None)
  -s SCALE, --scale SCALE
                        DOS scale factor (default: 2.0)
  -H HEIGHT, --height HEIGHT
                        Height of the plot in inches (default: 3.5)
  -W WIDTH, --width WIDTH
                        Width of the plot in inches (default: 3.3)
  -r RATIO, --ratio RATIO
                        Bandplot - dosplot width ratio (default: 3.0)
  -f FONT_SIZE, --font-size FONT_SIZE
                        Fontsize (default: 8)
  -o OUTPUT_FILE, --output-file OUTPUT_FILE
                        Path and name of the output file, excluding the format (default: fatbands)
  --format {pdf,png}    Output file format (default: pdf)
  --element ELEMENT     Element for orbital bubble plot (e.g., Fe) (default: None)
  --orbital-type {d,p,f}
                        Type of orbital to plot (d, p or f) (default: d)
  --bubble-min BUBBLE_MIN
                        Minimum bubble size (default: 0.05)
  --bubble-max BUBBLE_MAX
                        Maximum bubble size (default: 0.3)
  --bubble-scale BUBBLE_SCALE
                        Bubble size scaling factor (default: 100)
  --bubble-density BUBBLE_DENSITY
                        Bubble density (1: every point, 2: every second point, etc.) (default: 5)
  --bubble-threshold BUBBLE_THRESHOLD
                        Minimum weight to plot bubble (default: 0.05)


```

考虑SOC非自旋极化的情况下的代码：

```python

import numpy as np
import math
import pymatgen
import sys
import argparse
import logging
import os.path

from pymatgen.io.vasp.outputs import Procar, Vasprun
from pymatgen.io.vasp.inputs import Kpoints
from pymatgen.core import Structure
from pymatgen.electronic_structure.core import Spin, Orbital

import matplotlib.pyplot as plt
import matplotlib.colors as mcolors
from matplotlib.gridspec import GridSpec


class SaneFormatter(argparse.RawTextHelpFormatter, 
                    argparse.ArgumentDefaultsHelpFormatter):
    pass

parser = argparse.ArgumentParser(prog='plot_fatbands.py',description=("Plot projected band structure (fatbands) from a VASP calculation.\n" +
									'Author: Marco Cappelletti. Inspired by Kevin Waters (kwaters4.github.io) and sumo-bandplot.\n' +
                                    'By default it assumes that:\n'  +
									'\tthe current directory contains KPOINTS and vasprun.xml from the band structure calculation\n' +
                                    '\tthe directory ../dos contains vasprun.xml from the DOS calculation\n' +
                                    '\tthe parent directory (../) contains the POSCAR file\n' +
                                    '\tthe grandparent directory (../../) contains the POTCAR file\n')
									,formatter_class=SaneFormatter)
parser.add_argument('-B','--vasprun-file-bands', type=str, help='Path of the vasprun.xml file of the band calculation', default='vasprun.xml')
parser.add_argument('-K','--KPOINTS-file', type=str, help='Path of the KPOINTS file with the band path', default='KPOINTS')
parser.add_argument('-C','--POSCAR-file', type=str, help='Path of the POSCAR file', default='POSCAR')
parser.add_argument('-O','--PROCAR-file', type=str, help='Path of the PROCAR file from the band calculation', default='PROCAR')
parser.add_argument('-P','--POTCAR-file', type=str, help='Path of the POTCAR file', default='POTCAR')
parser.add_argument('-D','--vasprun-file-dos', type=str, help='Path of the vasprun.xml file of the dos calculation', default='../dos/vasprun.xml')
parser.add_argument('-p','--project', help='Band projections. Accepts 1-5 arguments. Nomenclature:\n'
													'\t- E/n: all orbitals of element with symbol E (H, C, N, ...) or atom index n (1, 2, ...)\n'
                                                    '\t- E/n.o: o-orbital of element with symbol E or atom index n (s, px, py, pz, dxy, ...)\n'
                                                    '\t- E/n.s.pz: s+pz orbitals of element with symbol E or atom index n\n'
                                                    '\t- X.s: s orbitals of all elements (literally X, see example)\n'
                                                    '\t- O.s.pz+N.pz: sum of O(s,pz) and N(pz)\n'
                                                    'You are free to mix anything you want. There is no restriction.\n'
                                                    'Examples (a number represents an atom index, starting from 1, as in PROCAR):\n'
                                                    '\t-p N O.s.pz+H.s C+X.pz =>'
                                                    ' color 1: N(all orb.), color 2: O(s+pz)+H(s), color 2: C(all orb.)+(all atoms pz)\n'
                                                    '\t-p 1+2+3 4.px.py.pz+5 H.s  =>'
                                                    ' color 1: 1(all orb.)+2(all orb.)+3(all orb.), color 2: 4(px+py+pz)+5+(px), color 3: H(s)\n'
                                                    , nargs='+', default=['X.px', 'X.py', 'X.s.pz'])
parser.add_argument('-t','--projection-type', type=str, help=f'Type of projection.\n'
                                                    '\t- blend: plot projections into the additive (r,g,b) space, or into the substractive (c,m,y) space.\n'
                                                    '\t- stack: plot stacked colored circles, with radius depending on contribution.\n', 
                                                    choices=['blend','stack'], default='stack')
parser.add_argument('--split', help='Split projections in different plots.', action='store_true')
parser.add_argument('-n','--normalization', type=str, help=f'Normalization of the projection.\n'
													'\t- all: with respect to all contributions.\n'
													'\t- selection: with respect to selection only.\n', choices=['all','selection'], default='selection')
parser.add_argument('-l','--max-l',type=int,default=1,choices=[1,2,3],
                                help='Maximum value of l (angular momemtum) for the projection.\
                                      Increases computational costs, so increase it only if necessary.')
parser.add_argument('-N','--no-projection',help='Do not perform any projection',action='store_true')
parser.add_argument('-m','--emin', type=float, help='Minimum of energy in the plot. If none, it chooses the lower limit', default=None)
parser.add_argument('-M','--emax', type=float, help='Maximum of energy in the plot. If none, it chooses the upper limit', default=None)
parser.add_argument('-s','--scale', type=float, help='DOS scale factor', default=1.0)
parser.add_argument('-H','--height', type=float, help='Height of the plot in inches', default=3.5)
parser.add_argument('-W','--width', type=float, help='Width of the plot in inches', default=3.3)
parser.add_argument('-r','--ratio', type=float, help='Bandplot - dosplot width ratio', default=3.0)
parser.add_argument('--blw','--band-lw', type=float, help='Linewidth of non-projected bands', default=2.0)
parser.add_argument('--bs','--band-size', type=float, help='Circle size of bands, when projection is on.', default=2.0)
parser.add_argument('--ba','--band-alpha', type=float, help='alpha value (transparency) of bands', default=1.0)
parser.add_argument('--dlw','--dos-lw', type=float, help='Linewidth of DOS', default=1.25)
parser.add_argument('--flw','--Fermi-lw', type=float, help='Linewidth of Fermi level. Set it to 0 to remove it', default=1.0)
parser.add_argument('--vlw','--vlines-lw', type=float, help='Linewidth of vertical lines. Set it to 0 to remove them', default=1.0)
parser.add_argument('--vla','--vlines-alpha', type=float, help='alpha value (transparency) of vertical lines.', default=1.0)
parser.add_argument('--glw','--grid-lw', type=float, help='Linewidth of grid. Set it to 0 to remove them', default=1.0)
parser.add_argument('--gla','--grid-alpha', type=float, help='alpha value (transparency) of grid lines.', default=1.0)
parser.add_argument('-f','--font-size', type=float, help='Fontsize', default=7)
parser.add_argument('--c-mode','--color-mode', type=str,  
                                 help='Color mode for blended fatbands. rbg (additive) = red, green, blue; cmy (substractive) = cyan, magenta, yellow.',
                                 choices=['rgb','cmy'], default='rgb')
parser.add_argument('--cmap','--colormap', type=str, 
                                 help='Color scheme for stacked fatbands.', 
                                 choices=['rgb','saturated','normal','pale','dark','alt','darkalt','accent','plt','sumo'], default='rgb')
parser.add_argument('--cord','--color-order', nargs='+', type=int, help='If you like to change the color order.\
                                                                E.g. --cmap rgbop --cord 3 2 1 4 5 means blue, green, red, orange, purple.\
                                                                Note: list of 5 integers regardless the number of projections! And first color is 1!!', 
                                                          default=[1,2,3,4,5])
parser.add_argument('--custc','--custom-colors', nargs='+', help='Custom colors, as in matplotlib. Examples:\n'
                                                                 '\t--custc red green blue\n'
                                                                 '\t--custc brown lime indigo', default='None')
parser.add_argument('-o','--output-file', type=str, help='Path and name of the output file, excluding the format', default='fatbands')
parser.add_argument('--format', type=str, help='Output file format', choices=['pdf','png'], default='pdf')
parser.add_argument('--redo','--readlog',  help='Rerun the last command, if plot_fatbands.log file is present. This overrides every other argument!', action='store_true')

args = parser.parse_args()
redo = args.redo

if redo is True:
    if os.path.isfile(f'plot_{args.output_file}.log') is False:
        raise ValueError(f'I cannot rerun: plot_fatbands_{args.output_file}.log does not exist')

    with open(f'plot_{args.output_file}.log') as f:
        argstr = f.readline()

    args = parser.parse_args(argstr.split()[1:])   


logging.basicConfig(
    filename=f'plot_{args.output_file}.log',
    level=logging.INFO,
    filemode="w",
    format="%(message)s",
)

if redo is True:
    logging.info(argstr)
else:
    logging.info(" ".join(sys.argv[:]))

scale = args.scale
no_proj = args.no_projection
N_proj = len(args.project)


# Set colors -----------------------------------------------------------------------------


if args.custc == 'None':

    match args.cmap:
        case 'rgb':
             colors = [[1,0,0], [0,1,0], [0,0,1], [1, 0.50, 0.14], [0.58,0.40,0.74]]
             color_names = {0: 'red', 1: 'green', 2: 'blue', 3: 'orange', 4: 'purple'}
        case 'saturated':
             colors = [mcolors.BASE_COLORS['r'], mcolors.BASE_COLORS['g'], mcolors.BASE_COLORS['b'],
                       mcolors.TABLEAU_COLORS['tab:orange'], mcolors.BASE_COLORS['m']]
             color_names = {0: 'red', 1: 'green', 2: 'blue', 3: 'orange', 4: 'magenta'}
        case 'pale':
             colors = [mcolors.TABLEAU_COLORS['tab:red'], mcolors.TABLEAU_COLORS['tab:green'], mcolors.TABLEAU_COLORS['tab:blue'],
                       mcolors.TABLEAU_COLORS['tab:orange'], mcolors.TABLEAU_COLORS['tab:purple']]
             color_names = {0: 'red', 1: 'green', 2: 'blue', 3: 'orange', 4: 'purple'}
        case 'normal':
             colors = [plt.cm.Set1.colors[0], plt.cm.Set1.colors[2], plt.cm.Set1.colors[1], plt.cm.Set1.colors[4], plt.cm.Set1.colors[3]]
             color_names = {0: 'red', 1: 'green', 2: 'blue', 3: 'orange', 4: 'purple'}
        case 'dark':
             colors = [mcolors.CSS4_COLORS['darkred'], mcolors.CSS4_COLORS['darkgreen'], mcolors.CSS4_COLORS['darkblue'], 
                       mcolors.CSS4_COLORS['chocolate'], mcolors.CSS4_COLORS['purple']]
             color_names = {0: 'red', 1: 'green', 2: 'blue', 3: 'orange', 4: 'purple'}
        case 'alt':
             colors = [plt.cm.Set2.colors[i] for i in range(5)]
             color_names = {0: 'teal', 1: 'orange', 2: 'blue', 3: 'pink', 4: 'green'}
        case 'darkalt':
             colors = [plt.cm.Dark2.colors[i] for i in range(5)]
             color_names = {0: 'teal', 1: 'orange', 2: 'blue', 3: 'pink', 4: 'green'}
        case 'accent':
             colors = [plt.cm.Accent.colors[i] for i in range(5)]
             color_names = {0: 'green', 1: 'liliac', 2: 'orange', 3: 'yellow', 4: 'blue'}
        case 'plt':
             colors = [plt.cm.tab10.colors[i] for i in range(5)]
             color_names = {0: 'blue', 1: 'orange', 2: 'green', 3: 'red', 4: 'purple'}
        case 'sumo':
             colors = ["#3952A3", "#FAA41A", "#67BC47", "#6ECCDD", "#ED2025"]
             color_names = {0: 'blue', 1: 'orange', 2: 'green', 3: 'red', 4: 'purple'}

    if args.projection_type == 'blend':
        colors = np.array([[1,0,0], [0,1,0], [0,0,1]])
        color_names = {0: 'red', 1: 'green', 2: 'blue'}
        if args.c_mode == 'cmy':
            colors = 1 - colors
            color_names = {0: 'cyan', 1: 'magenta', 2: 'yellow'}

else:
    colors = [ mcolors.CSS4_COLORS[cval] for cval in args.custc ] 

color_order = {0: args.cord[0]-1, 1: args.cord[1]-1, 2: args.cord[2]-1, 3: args.cord[3]-1, 4: args.cord[4]-1}

# ----------------------------------------------------------------------------------------


def CheckInput():
    # accepts only 1-3 entries for the projection
    if N_proj < 1 or N_proj > 3:
        if args.split is False:
            raise ValueError('Only 1, 2 or 3 components allowed for the non-split projection')
        elif N_proj < 2 or N_proj > 5:
            raise ValueError('2-5 components allowed for the split projection')
    elif N_proj == 1 and args.normalization == 'selection':
        print('\tWARNING: you selected 1 projection and \'selection\' normalization. This does not make sense. Normalization is changed to \'all\'')
        logging.info('WARNING: normalization is changed to \'all\'')
        args.normalization='all'
    
    if args.split is True and args.projection_type == 'blend':
        raise ValueError('Only stacked projection allowed for split')

    if args.split is True and no_proj is True:
        raise ValueError('Cannot split non-projected bands!')





def plotcircles(ax, KPOINTS, band_energies, contrib, index):

    if args.split is False and args.projection_type == 'stack':
        sizes = args.bs**2 * contrib[:,:,index:3].sum(axis=2)**2
    elif args.split is True:
        sizes = args.bs**2 * contrib**2

    for bidx,be in enumerate(band_energies):
        if args.projection_type == 'blend':
            ax.scatter(KPOINTS,be,s=args.bs/2,color=colors[color_order[index]],alpha=contrib[bidx,:,index]**2,edgecolor='none')
        elif  args.projection_type == 'stack':
            ax.plot(KPOINTS,be,lw=args.blw/4,color='k',alpha=args.ba,zorder=0)
            ax.scatter(KPOINTS,be,s=sizes[bidx],color=colors[color_order[index]],edgecolor='none')

    



def CalculateProjectionsAndPlot():

    # calculates contributions for bands and DOS projections
    el_orbs = []
    el_orbs_labels = []

    # read the projections
    # 1-5 components, e.g. 'N.s.pz', 'N.s+O.s.pz', 'N+O.s', 'N+O', 'X', 'X.s', 'X.s+N.px.py.pz', ...
    for component in args.project:
        element_components = component.split("+")   # split elements, e.g. 'N.s+O.s.pz' becomes ['N.s', 'O.s.pz']
        color_component = []			# list of components for one color
        label_text = []                 # more readable, user-friendly text for the legend
        for element_component in element_components:  # e.g. for element in the list ['N.s', 'O.s.pz'] (example above)
            splits = element_component.split(".")   # e.g. 'N.s.pz' converted to ['N', 's', 'pz']
            element = splits[0]                     # first element is the atom symbol, e.g. 'N'
            if len(splits) == 1:                    # if splits has one element, then no orbitals are specified (e.g. 'N') => plot all orbitals (= 'all')
                orbitals = 'all'
            else:
                orbitals = splits[1:]               # e.g. ['s', 'pz'] 
            color_component.append([element,orbitals])	

            if element == 'X':                      # 'X' represents all atoms
                if len(splits) == 1:                # if input is only 'X'
                    label_text.append('s+p_x+p_y+p_z')      # this makes no sense to choose, it's the projection of all atoms and orbitals, but who am I to judge
                else:
                    label_text.append("+".join(orbitals).replace('p','p_'))   # more readable, e.g. 'X.s.pz' becomes 's+p_z'
            else:
                if len(splits) == 1:                        # all orbitals, only the element: 'N'; or the index: '2'
                    if element.isnumeric() is True:
                        label_text.append(atom_labels[int(element)-1]+element)
                    else:
                        label_text.append(element)
                else:
                    if element.isnumeric() is True:
                        label_text.append(f"{atom_labels[int(element)-1]+element}({','.join(orbitals).replace('p','p_')})")
                    else:
                        label_text.append(f"{element}({','.join(orbitals).replace('p','p_')})")   # e.g. 'O.s.pz' becomes 'O(s+p_z)'
        el_orbs.append(color_component)
        el_orbs_labels.append("+".join(label_text))         # e.g. 'O.s.pz+H.s' becomes 'O(s+p_z)+H(s)'

    

    logging.info(f'Calculating contributions for orbitals with angular momentum up to l = {args.max_l}. Ignoring the rest if l < 3')
    if args.normalization == 'selection':
        logging.info(f'Normalization mode is {args.normalization}: selected contributions sum to 1. Other contributions (if any) will not be visible in the plot!')
    else:
        logging.info(f'Normalization mode is {args.normalization}: selected contributions are normalized with respect to all contributions.')
            
    print(f'\tColormap: {args.cmap}')            
    print(f'\tBands are projected into {N_proj} contributions:')
    logging.info(f'Bands are projected into {N_proj} contributions:')
    for color_idx, color_contrib in enumerate(el_orbs_labels):
        print(f'\t    - color {color_names[color_order[color_idx]]}:\t{color_contrib}')
        logging.info(f'\t-color {color_names[color_order[color_idx]]}:\t{color_contrib}')

    print(f'\tNormalization mode is: \'{args.normalization}\'')
    print(f'\tProjection type is: \'{args.projection_type}\'')


    logging.info('\n------------------------------------------------------------------------')
    logging.info('Contribution table for high-symmetry points (only for plotted bands)')

    logging.info(f'\nband n' + '\t' + '\t'.join(labels))



    # as in VASP - 修改轨道名称映射
    orbital_values = { 's': 0,
                       'py': 1, 'pz': 2, 'px': 3,
                       'dxy': 4, 'dyz': 5, 'dz2': 6, 'dxz': 7, 'x2-y2': 8 }  # 修改这里：x2_y2 -> x2-y2

    # 动态检测PROCAR的实际轨道数量
    try:
        # 获取第一个原子的轨道数量作为参考
        actual_orbital_count = len(data[Spin.up][0][0][0])
        print(f"检测到PROCAR文件包含 {actual_orbital_count} 个轨道")
        # 使用实际轨道数量或理论最大值中的较小值
        max_l_index = min((args.max_l + 1)**2, actual_orbital_count)
    except:
        max_l_index = min((args.max_l + 1)**2, 9)  # 安全回退

    # contributions to the band per each band, k-point, and color: contrib_bands[band][k-point][color]
    contrib_bands = np.zeros((max_band_to_plot-min_band_to_plot+1, len(bands.kpoints), N_proj))

    # contributions to the DOS per each color: contrib_dos[color][energy]
    contrib_dos = np.zeros((N_proj, len(dosrun.pdos[0][Orbital.s][Spin.up])))


    # obtain contributions
    # sum over all bands to plot
    for b in range(max_band_to_plot-min_band_to_plot+1):
        # sum over all k-points
        for k in range(len(bands.kpoints)):
            for color_idx, color_contrib in enumerate(el_orbs): # color_idx: 1-5. color_contrib: list of [elements, orbitals] for each color
                for element_contrib in color_contrib:
                    element = element_contrib[0]        # e.g. 'X', 'N'
                    orbitals = element_contrib[1]       # e.g. 'all', 's', ['s', 'pz']
                    if element == 'X':                  # if all atoms, get all indexes
                        element_indexes = range(len(atom_labels))
                    elif element.isnumeric() is True:
                        element_indexes = [int(element)-1]
                    else:                               # else, get the indexes with label = atom symbol (e.g. 'C')
                        element_indexes = [i for i, x in enumerate(atom_labels) if x == element]

                    if orbitals == 'all':
                        orbital_indexes = range(0, max_l_index)  # sum all orbitals if 'all'
                    else:
                        orbital_indexes = [orbital_values[o] for o in orbitals if o in orbital_values]

                    for i in element_indexes:
                        for j in orbital_indexes:
                            # 更安全的边界检查 - 关键修改
                            try:
                                # 先检查所有索引是否在有效范围内
                                if (i < len(data[Spin.up][k][b+min_band_to_plot]) and 
                                    j < len(data[Spin.up][k][b+min_band_to_plot][i])):
                                    contrib_bands[b,k,color_idx] += data[Spin.up][k][b+min_band_to_plot][i][j]**2
                                
                                if k == 0 and b == 0:	# needs to be done just once 
                                    try:
                                        # DOS部分也添加边界检查
                                        if (i < len(dosrun.pdos) and 
                                            j < len(dosrun.pdos[i])):
                                            contrib_dos[color_idx] += np.array(dosrun.pdos[i][Orbital(j)][Spin.up])
                                    except (IndexError, KeyError):
                                        pass  # 如果出错就跳过
                            except (IndexError, KeyError):
                                pass  # 如果任何索引访问出错，跳过

            # normalization
            if args.normalization == 'selection':
                if np.sum(contrib_bands[b,k,:]) != 0:
                    contrib_bands[b,k,:] = contrib_bands[b,k,:]/np.sum(contrib_bands[b,k,:])
                elif k in labels_kpt_num+1:     # I don't know why, VASP prints all contribution to zero at those points
                    contrib_bands[b,k,:] = contrib_bands[b,k-1,:]

                # print contributions at high-symmetry point to log file
            elif args.normalization == 'all':
                tot = 0.0
                for i in range(len(atom_labels)):
                    for j in range(0, min(max_l_index, 9)):  # 限制最大为9个轨道
                        try:
                            if (i < len(data[Spin.up][k][b+min_band_to_plot]) and 
                                j < len(data[Spin.up][k][b+min_band_to_plot][i])):
                                tot += data[Spin.up][k][b+min_band_to_plot][i][j]**2
                        except (IndexError, KeyError):
                            pass
                if tot != 0:
                    contrib_bands[b,k,:] = contrib_bands[b,k,:]/tot
        if b+min_band_to_plot < 9:
            b_str = '  ' + str(b+min_band_to_plot+1)
        elif b+min_band_to_plot < 99:
            b_str = ' ' + str(b+min_band_to_plot+1)
        else:
            b_str = str(b+min_band_to_plot+1)
        logging.info(f'{b_str}: ' + '\t'
                     + '\t'.join('[' + ','.join(f'{x:.2f}' for x in contrib_bands[b, lkn, :])
                     + ']' for lkn in labels_kpt_num))


    # Plotting -----------------------------------------------------------------

    bands_to_plot = bands.bands[Spin.up][min_band_to_plot:max_band_to_plot+1] - bands.efermi

    if args.split is False:
        if args.projection_type == 'stack':
            for proj_n in range(N_proj):
                plotcircles(ax_bands,
                    KPOINTS,
                    bands_to_plot,
                    contrib_bands,
                    proj_n)
                
                ax_DOS.plot(contrib_dos[proj_n],dosrun.tdos.energies - dosrun.efermi, \
                    c=colors[color_order[proj_n]], label = f'${el_orbs_labels[proj_n]}$', linewidth = args.dlw)
        elif args.projection_type == 'blend':
            for proj_n in range(N_proj):
                plotcircles(ax_bands,
                    KPOINTS,
                    bands_to_plot,
                    contrib_bands,
                    proj_n)

            ax_DOS.plot(contrib_dos[0],dosrun.tdos.energies - dosrun.efermi, \
                   c=colors[color_order[0]], label = f'${el_orbs_labels[0]}$', linewidth = args.dlw)
            ax_DOS.plot(contrib_dos[1],dosrun.tdos.energies - dosrun.efermi, \
                   c=colors[color_order[1]], label = f'${el_orbs_labels[1]}$', linewidth = args.dlw)
            if len(el_orbs) == 3:
               ax_DOS.plot(contrib_dos[2],dosrun.tdos.energies - dosrun.efermi, \
                   c=colors[color_order[2]], label = f'${el_orbs_labels[2]}$', linewidth = args.dlw)

    else:
        for proj_n in range(N_proj):
            ax = ax_bands[proj_n]
            plotcircles(ax,
                KPOINTS,
                bands_to_plot,
                contrib_bands[:,:,proj_n],
                proj_n)

            # plot DOS
            ax_DOS.plot(contrib_dos[proj_n],dosrun.tdos.energies - dosrun.efermi, \
                c=colors[color_order[proj_n]], label = f'${el_orbs_labels[proj_n]}$', linewidth = args.dlw)

    # --------------------------------------------------------------------------










#----- Program starts -------------------------------------------------------------------------------------------

if __name__ == "__main__":
    print('--- plot_fatbands.py --------------------------------------')
    print(f'\tPlotting fatbands into {args.output_file}.{args.format}. Size: {args.width} x {args.height} inches.')
    if redo is True:
        print(f'\tRedoing previous run: {argstr}',end='')
    print(f'\tAdditional data is printed in plot_{args.output_file}.log')
    logging.info(f'Plotting fatbands into {args.output_file}.{args.format}. Size: {args.width} x {args.height} inches.\n')

    CheckInput()


    # Read files ---------------------------------------------------------------

    # Load Structure
    structure = Structure.from_file(args.POSCAR_file)
    # 修改原子标签获取方式 - 兼容新版pymatgen
    try:
        atom_labels = [site.species_string for site in structure]
    except AttributeError:
        atom_labels = structure.labels

    # Load Band Structure Calculations
    bands = Vasprun(args.vasprun_file_bands,parse_potcar_file=args.POTCAR_file).get_band_structure(args.KPOINTS_file, line_mode = True)
    # Read KPOINTS file with path
    kpts = Kpoints.from_file(args.KPOINTS_file)  

    if no_proj is False:
        # projected bands
        data = Procar(args.PROCAR_file).data

    # density of states
    dosrun = Vasprun(args.vasprun_file_dos,parse_potcar_file=args.POTCAR_file)

    # --------------------------------------------------------------------------


    # Interpret k-points -------------------------------------------------------

    # k-point labels
    n_labels = len(kpts.labels)
    labels = []
    labels.append(kpts.labels[0])
    for label_idx in range(1,n_labels,2):
        labels.append(kpts.labels[label_idx])

    # get kpoint number for each high symmetry point
    labels_kpt_num = np.zeros(len(labels), dtype=int)
    lab_idx = 0
    for idx, bkpt in enumerate(bands.kpoints):
        if bkpt.label is not None and idx-1 not in labels_kpt_num: # usually they are duplicated, I just take the first
            labels_kpt_num[lab_idx] = idx
            lab_idx += 1

    # Number of points between kpoints, found in the KPOINTS file
    step = kpts.num_kpts

    # --------------------------------------------------------------------------


    # Initialize plot ----------------------------------------------------------

    # general options for plot
    font = {'family': 'serif', 'size': args.font_size}
    plt.rc('font', **font)

    # if no split is requested: one band plot and one DOS plot
    if args.split is False:
        # set up 2 graph with aspec ratio args.ratio/1
        # plot 1: bands diagram
        # plot 2: DOS
        gs = GridSpec(1, 2, width_ratios=[args.ratio,1], wspace=0.1)
        fig = plt.figure(figsize=(args.width, args.height))
        ax_bands = plt.subplot(gs[0])
        ax_DOS = plt.subplot(gs[1]) #, sharey=ax1)

    # if split is requested: N band plots (N=number of projections, 1-3) and one DOS plot
    else:
        print('\tWARNING: split is requested, remember to change plot width!')
        width_ratios = [ args.ratio/N_proj for proj_n in range(N_proj) ]
        width_ratios.append(args.ratio/(2*N_proj))
        gs = GridSpec(1, N_proj+1, width_ratios=width_ratios, wspace=0.1)
        fig = plt.figure(figsize=(args.width, args.height))
        ax_bands = [ plt.subplot(gs[proj_n]) for proj_n in range(N_proj) ]
        ax_DOS = plt.subplot(gs[N_proj]) 
        
    # --------------------------------------------------------------------------

    # Set both fermi levels equal to the band fermi level
    bands.efermi =  dosrun.efermi #= 0

    # set y limits for the plot
    emin = args.emin
    emax = args.emax

    # if either is not defined, get the min and/or the max of energy from bands.bands.keys()
    if emin is None and emax is None:
        emin=1000
        emax=-1000
        for spin in bands.bands.keys():
            for b in range(bands.nb_bands):
                emin = min(emin, min(bands.bands[spin][b]))
                emax = max(emax, max(bands.bands[spin][b]))
        emin = emin - bands.efermi
        emax = emax - bands.efermi
    elif emin is None:
        emin=1000
        for spin in bands.bands.keys():
            for b in range(bands.nb_bands):
                emin = min(emin, min(bands.bands[spin][b]))
        emin = emin - bands.efermi
    elif emax is None:
        emax=-1000
        for spin in bands.bands.keys():
            for b in range(bands.nb_bands):
                emax = max(emax, max(bands.bands[spin][b]))
        emax = emax - bands.efermi

    # set first and last bands to plot, so that it calculates the projections only on those
    min_band_to_plot = 1000
    max_band_to_plot = -1

    for spin in bands.bands.keys():
        min_band_to_plot = min(min_band_to_plot, np.min(np.where(bands.bands[spin] >= emin + bands.efermi)[0]))
        max_band_to_plot = max(max_band_to_plot, np.max(np.where(bands.bands[spin] <= emax + bands.efermi)[0]))

    print(f'\tPlotting bands from {emin} to {emax} eV, band numbers from {min_band_to_plot+1} to {max_band_to_plot+1}')

    reciprocal = bands.lattice_rec.matrix/(2*math.pi)

    # Empty lists used for caculating the distances between K-Points
    # unchanged from Kevin Waters's script
    KPOINTS = [0.0]
    DIST = 0.0
    # Create list with distances between Kpoints (Individual), corrects the spacing
    for k in range(len(bands.kpoints)-1 ):
        Dist = np.subtract(bands.kpoints[k+1].frac_coords,bands.kpoints[k].frac_coords)
        DIST += np.linalg.norm(np.dot(reciprocal,Dist))
        KPOINTS.append(DIST)


    TICKS = [0.0]
    for i in range(step,len(KPOINTS)+step,step):
        TICKS.append(KPOINTS[i-1])
    # set y-axis limit
    if args.split is False:
        ax_bands.set_ylabel(r"$E - E_f$ (eV)",labelpad=1)   #labelpad might work bad
        ax_bands.set_ylim(emin, emax)
        ax_bands.grid(lw=args.glw,alpha=0.5)
        ax_bands.set_axisbelow(True)
        ax_bands.hlines(y=0, xmin=0, xmax=len(bands.kpoints), color="k", lw=args.flw)
        for i in range(step,len(KPOINTS)+step,step):
            ax_bands.vlines(KPOINTS[i-1], emin, emax, "k",lw=args.vlw,alpha=args.vla)
        ax_bands.set_xticks(TICKS)
        ax_bands.set_xticklabels(labels)
        ax_bands.tick_params(axis='x', which='both', length=0, pad=5)
        ax_bands.set_xlim(0, KPOINTS[-1])
    else:
        ax_bands[0].set_ylabel(r"$E - E_f$ (eV)",labelpad=1)   #labelpad might work bad
        for axis in ax_bands:
            axis.set_ylim(emin,emax)
            axis.grid(lw=args.glw,alpha=0.5)
            axis.set_axisbelow(True)
            axis.hlines(y=0, xmin=0, xmax=len(bands.kpoints), color="k", lw=args.flw)
            for i in range(step,len(KPOINTS)+step,step):
                axis.vlines(KPOINTS[i-1], emin, emax, "k",lw=args.vlw,alpha=args.vla)
            axis.set_xticks(TICKS)
            axis.set_xticklabels(labels)
            axis.tick_params(axis='x', which='both', length=0, pad=5)
            axis.set_xlim(0, KPOINTS[-1])
            if axis != ax_bands[0]:
                axis.set_yticks([])
                axis.set_yticklabels([])

    ax_DOS.set_ylim(emin, emax)


    if no_proj is False:
        CalculateProjectionsAndPlot()
        DOSlabel='total'
        ax_DOS.legend(fancybox=False, shadow=False, prop={'size': args.font_size-1},labelspacing=0.15,borderpad=0.20,handlelength=1.2,framealpha=0.6)
    else:
        print('\tNo projection requested. Plotting normal bands.')
        for b in range(min_band_to_plot,max_band_to_plot+1): 
            ax_bands.plot(KPOINTS,[e - bands.efermi for e in bands.bands[Spin.up][b]], lw=args.blw, color='k')
        DOSlabel=None

    ax_DOS.fill_betweenx(dosrun.tdos.energies - dosrun.efermi,
        0,dosrun.tdos.densities[Spin.up],
        color = (0.7, 0.7, 0.7),
        facecolor = (0.7, 0.7, 0.7))
    ax_DOS.plot(dosrun.tdos.densities[Spin.up],
        dosrun.tdos.energies - dosrun.efermi,
        color = (0.6, 0.6, 0.6),
        label = DOSlabel, lw=args.dlw)


    # scaling factor for the x axis limit, if the peaks are too high
    maxdos = max(dosrun.tdos.densities[Spin.up])/scale

    
    ax_DOS.set_yticklabels([])
    ax_DOS.grid(lw=args.glw,alpha=args.gla)
    ax_DOS.tick_params('y', length=0, width=1, which='major')
    ax_DOS.set_xticks([])
    ax_DOS.set_xlim(0,maxdos)
    ax_DOS.hlines(y=0, xmin=0, xmax=maxdos, color="k", lw=args.flw)
    ax_DOS.set_xlabel("DOS",labelpad=5)

    # Plotting 
    # -----------------
    plt.savefig(f"{args.output_file}.{args.format}", format=args.format, bbox_inches='tight', dpi=400)


    print('\tFile saved.')
    print('-----------------------------------------------------------')



```