---
layout: post
title: "pythTB的学习_wf_array to in v2.0WFArray"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20251209-PythonTB_tb
---


# <center>Tutorials​</center>

### 初始化与填充 WFArray

在 PythTB 的旧版本中，wf_array类与 tb_model类紧密耦合。初始化 wf_array时，它会从关联的 tb_model中读取晶格信息。而在 v2.0 版本中，与 TBModel的做法类似，我们将显式地将一个 Lattice对
象传递给 WFArray的构造函数。除了提高灵活性，这也使我们能够创建不绑定于任何特定 TBModel的 WFArray对象。例如，用户可能希望存储源自绝热循环中多个 TBModel的状态，而这些状态没有一个单一的
TBModel可以完全描述。

Compare to versions 1.x:

```python

# v1.x
from pythtb import tb_model, wf_array
model = tb_model(1, 1, lat=[[1.0, 0.0], [0.0, 1.0]], orb=[[0, 1/3, 2/3]])
wfa = wf_array(model, [20])
wfa.solve_on_grid(0.0)

```

在 solve_on_grid方法中，wf_array会先生成 k 点网格，并用来自 model的波函数数据填充自身。之后，这个 k 点网格会被丢弃，wf_array仅保留波函数数据本身。这导致关于 k 点结构的信息丢失，如果后续分析（如绘图）需要这些 k 点信息，用户需要自己手动追踪和保存对应的 k 点网格。

1. 创建一个描述系统晶格结构的对象。

```python

lattice = Lattice(
    lat_vecs=[[1.0]], orb_vecs=[[0.0], [1 / 3], [2 / 3]], periodic_dirs=[0]
)

```

2. 创建一个用于描述k点​和参数网格​的对象。

```python

mesh = Mesh(["k"])

```

3. 用所需的k点和参数值填充Mesh。

```python

mesh.build_grid([20])

```

4. 将这些对象传递给构造函数

```python

wfa = WFArray(lattice=lattice, mesh=mesh)

```

现在，如果我们想用一个给定的 TBModel的能量本征态来填充 WFArray，可以通过调用 WFArray.solve_model()函数来实现。

```python

t = -1.3
delta = 2.0

model = TBModel(lattice=lattice)

# nearest-neighbour hoppings (last hop wraps to the next cell)
model.set_hop(t, 0, 1, [0])
model.set_hop(t, 1, 2, [0])
model.set_hop(t, 2, 0, [1])

# Per-orbital onsite as lambdas of lmbda
onsite = [
    lambda lmbda: delta * -np.cos(2 * np.pi * (lmbda - 0 / 3)),
    lambda lmbda: delta * -np.cos(2 * np.pi * (lmbda - 1 / 3)),
    lambda lmbda: delta * -np.cos(2 * np.pi * (lmbda - 2 / 3)),
]

model.set_onsite(onsite)

```

```python

model_fixed = model.with_parameters(lmbda=0.25)
wfa.solve_model(model_fixed)

```

我们可以通过索引来访问存储在 WFArray中的单个波函数，这与先前版本中的操作方式相似。例如，wfa[k_index]将返回指定网格索引处的波函数。

```python

wfa[2]

```

```python

array([[ 0.48119032+0.j        ,  0.80505946-0.06370792j,
         0.33915892-0.0353223j ],
       [ 0.77558258+0.j        , -0.54837962-0.05902583j,
         0.21322754+0.22091043j],
       [-0.40856766+0.j        , -0.09282883-0.1870805j ,
         0.80421332+0.3777527j ]])

```

与先前版本一样，在贝里相位计算及其他运算中，布里渊区边界会自动应用内部的周期性边界条件。

### 绝热循环中的 WFArray

我们将复用上文使用过的同一个晶格，但现在要创建一个包含绝热参数轴的 Mesh。这个参数在 0 到 1 的范围内变化，共分 11 个步骤。这个参数可以代表例如晶格的畸变或外部场的变化。

Mesh lambda 01

请回忆 Mesh 教程中的内容：我们需要根据在函数中变化的参数名称来命名这个坐标轴（如果您错过了，可以参阅上面的函数说明）。

λ TBModel1

```python

mesh = Mesh(["k", "l"], axis_names=["kx", "lmbda"])

```

现在我们将构建网格，指定绝热参数的范围从0到1，共分11个步骤。

```python

mesh.build_grid(
    shape=(31, 21),
    gamma_centered=True,
    lambda_start=0.0,
    lambda_stop=1.0,
    lambda_endpoints=True,
)

```

如果我们希望将 λ 轴设置为一个绝热循环，我们需要为对应的轴索引设置 loop 参数。组合空间（k, λ）是二维的，且维度排列在 k 维度（这里只有 1 个 k 维度）之后，因此组件索引是 1（按 Python 计
数方式）。这表明，遍历轴 1 会使网格向量的第二个分量（Python 计数为 1）形成环路，从而使得环路末端的哈密顿量与起始端的哈密顿量相连。

由于 λ=1 的终点与 λ=0 的起点是等效的，我们也将该轴标记为闭合。这可以通过将 closed 参数设置为 True 来实现。

```python

mesh.loop(
    axis_idx=1, component_idx=1, closed=True
)  # form the lambda axis into a closed loop
print(mesh)

```

```python

Mesh Summary
========================================
Type: grid
Dimensionality: 1 k-dim(s) + 1 λ-dim(s)
Number of mesh points: 651
Full shape: (31, 21, 2)
k-axes: [Axis(type=k, name=kx, size=31)]
λ-axes: [Axis(type=l, name=lmbda, size=21)]
Is a torus in k-space (all k-axes wind BZ): yes
Loops: (axis 0, comp 0, winds_bz=yes, closed=no), (axis 1, comp 1, winds_bz=no, closed=yes)

```

初始化WFArray

```python

wfa = WFArray(lattice, mesh)

```
最后，我们调用函数，在组合网格的每个点 (k, λ) 上，用 TBModel 的本征态填充 WFAArray。

```python

wfa.solve_model(model=model)

```

我们可以通过比较绝热循环开始和结束时的波函数，来验证该轴是否被正确设置为一个环路

```python

np.allclose(wfa[0, 0], wfa[0, -1])  # first k-point, first and last lambda points

```

```python

True

```