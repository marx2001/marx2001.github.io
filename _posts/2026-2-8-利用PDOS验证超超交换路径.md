---
layout: post
title: "(原创自研)利用PDOS验证超超交换路径"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20260208-pdos
---

## <center>说明</center>

暂无
## <center>代码</center>  

用这个代码，计算出设置范围内的指定原子的价带顶和导带底的分轨道能级排布顺序。

```python

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
1step.py  (VB + CB grouping + level diagram)

功能：
- 读取 UP/DW 两个 PDOS 文件（能量网格必须一致）
- 对 d 轨道 (dxy, dyz, dz2, dxz, dx2y2) 在两个能窗内分别：
  1) 计算余弦相似度矩阵 sim_matrix
  2) 连通分量分组 auto_groups（阈值 thr）
  3) 计算每轨道 band center E_center（谱权重质心）与 N_window
  4) 画能级示意图（按 E_center 排序，标注简并组）

输出（prefix = --out_prefix）：
- <prefix>_VB_sim_matrix.csv
- <prefix>_VB_orb_centers.csv
- <prefix>_VB_auto_groups.csv
- <prefix>_VB_levels.png
- <prefix>_CB_sim_matrix.csv
- <prefix>_CB_orb_centers.csv
- <prefix>_CB_auto_groups.csv
- <prefix>_CB_levels.png

说明：
- Ef 位置由 --Ef 指定（默认 0.0），脚本不从 OUTCAR/DOSCAR 读取。
- 这里的“能级/分组”是基于指定能窗内 PDOS 形状相似性 + band center（质心），用于机制图示意，不等同严格晶场本征值。
"""

import argparse
from pathlib import Path
import re
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


# ====== PDOS 文件列布局（与你现有脚本一致）======
COLS = ["E","s","py","pz","px","dxy","dyz","dz2","dxz","dx2y2","tot"]
D_ORBS = ["dxy","dyz","dz2","dxz","dx2y2"]


def load_pdos(path: Path) -> pd.DataFrame:
    return pd.read_csv(path, sep=r"\s+", comment="#", names=COLS, skiprows=1)


def trapz(E: np.ndarray, Y: np.ndarray) -> float:
    return float(np.trapz(Y, E))


def band_center(E: np.ndarray, D: np.ndarray, Emin: float, Emax: float):
    m = (E >= Emin) & (E <= Emax)
    Ew = E[m]
    Dw = D[m]
    denom = trapz(Ew, Dw)
    if abs(denom) < 1e-14:
        return np.nan, 0.0
    num = trapz(Ew, Ew * Dw)
    return num / denom, denom


def cosine_sim(E: np.ndarray, A: np.ndarray, B: np.ndarray, Emin: float, Emax: float):
    m = (E >= Emin) & (E <= Emax)
    Em = E[m]
    a = A[m]
    b = B[m]
    na = np.sqrt(trapz(Em, a * a))
    nb = np.sqrt(trapz(Em, b * b))
    if na < 1e-14 or nb < 1e-14:
        return np.nan
    return trapz(Em, a * b) / (na * nb)


def auto_groups(sim_mat: np.ndarray, labels, thr: float):
    """
    Build graph with edge(u,v) if sim>=thr, return connected components.
    """
    n = len(labels)
    visited = [False] * n
    groups = []
    for i in range(n):
        if visited[i]:
            continue
        stack = [i]
        comp = []
        visited[i] = True
        while stack:
            u = stack.pop()
            comp.append(u)
            for v in range(n):
                if (not visited[v]) and (sim_mat[u, v] >= thr):
                    visited[v] = True
                    stack.append(v)
        groups.append([labels[k] for k in sorted(comp)])
    return groups


def compute_window(E: np.ndarray, D: np.ndarray, Emin: float, Emax: float, thr: float, tag: str):
    """
    返回：
      df_sim, df_orb, df_grp, groups(list[list[str]])
    """
    n = len(D_ORBS)
    sim = np.zeros((n, n), float)
    for i in range(n):
        for j in range(n):
            if i == j:
                sim[i, j] = 1.0
            elif j < i:
                sim[i, j] = sim[j, i]
            else:
                sim[i, j] = cosine_sim(E, D[:, i], D[:, j], Emin, Emax)

    df_sim = pd.DataFrame(sim, index=D_ORBS, columns=D_ORBS)
    groups = auto_groups(sim, D_ORBS, thr=thr)

    # per-orb centers
    orb_rows = []
    for i, orb in enumerate(D_ORBS):
        Ec, Nw = band_center(E, D[:, i], Emin, Emax)
        orb_rows.append({
            "orb": orb,
            "E_center": Ec,
            "N_window": Nw,
            "window": f"[{Emin},{Emax}]",
            "tag": tag
        })
    df_orb = pd.DataFrame(orb_rows).sort_values("E_center")

    # per-group centers (sum DOS)
    grp_rows = []
    for g in groups:
        idx = [D_ORBS.index(o) for o in g]
        Dg = D[:, idx].sum(axis=1)
        Ec, Nw = band_center(E, Dg, Emin, Emax)
        grp_rows.append({
            "group": "(" + ",".join(g) + ")",
            "members": ",".join(g),
            "size": len(g),
            "E_center": Ec,
            "N_window": Nw,
            "window": f"[{Emin},{Emax}]",
            "tag": tag
        })
    df_grp = pd.DataFrame(grp_rows).sort_values("E_center")

    return df_sim, df_orb, df_grp, groups


def parse_orb_list(s):
    tokens = re.findall(r"(dxy|dxz|dyz|dz2|dx2y2)", str(s), flags=re.IGNORECASE)
    return [t.lower() for t in tokens]


def draw_level_diagram(df_grp: pd.DataFrame, out_png: str, title: str, eref: float = 0.0,
                       fontsize: int = 12, linewidth: float = 3.0):
    """
    用 df_grp（每组 E_center）画能级示意图。
    """
    # 过滤无效
    df = df_grp.copy()
    df = df[np.isfinite(df["E_center"].values)]
    if len(df) == 0:
        raise RuntimeError("No valid E_center to plot.")

    # 按能量排序
    df = df.sort_values("E_center").reset_index(drop=True)

    ys = (df["E_center"].to_numpy(float) - eref)
    labels = []
    sizes = []
    for _, r in df.iterrows():
        orbs = parse_orb_list(r["members"])
        label = " + ".join(orbs) if orbs else str(r["group"])
        labels.append(label)
        sizes.append(int(r["size"]))

    n = len(df)
    fig_h = max(4.0, 1.2 + 0.8 * n)
    fig, ax = plt.subplots(figsize=(6.4, fig_h))

    x0 = 0.0
    xspan = 0.55
    x_offsets = np.linspace(-0.15, 0.15, n) if n > 1 else np.array([0.0])

    for i in range(n):
        y = ys[i]
        xo = x_offsets[i]
        ax.hlines(y, x0 - xspan + xo, x0 + xspan + xo, linewidth=linewidth)
        ax.text(x0 + xspan + 0.10, y, f"{labels[i]} ({sizes[i]})", va="center", fontsize=fontsize)
        ax.text(x0 - xspan - 0.10, y, f"{y:.3f} eV", va="center", ha="right", fontsize=fontsize-1)

    ax.set_xlim(-1.2, 1.9)
    ax.set_xticks([])
    ax.set_ylabel(f"Energy (eV)  [E_center - {eref:g}]", fontsize=fontsize)
    ax.grid(True, axis="y", linestyle="--", linewidth=0.6, alpha=0.5)
    ax.set_title(title, fontsize=fontsize + 2)

    ypad = 0.15 * (float(np.nanmax(ys)) - float(np.nanmin(ys)) + 1e-9)
    ax.set_ylim(float(np.nanmin(ys) - ypad), float(np.nanmax(ys) + ypad))

    fig.tight_layout()
    fig.savefig(out_png, dpi=300)
    plt.close(fig)


def main():
    ap = argparse.ArgumentParser()

    ap.add_argument("--up", required=True, help="spin-up PDOS file")
    ap.add_argument("--dw", required=True, help="spin-down PDOS file")

    ap.add_argument("--Ef", type=float, default=0.0,
                    help="Fermi level on PDOS energy axis (used for defining VB/CB windows around it). default=0")

    # windows defined relative to Ef
    ap.add_argument("--vb_width", type=float, default=1.0,
                    help="VB window width below Ef: [Ef-vb_width, Ef]")
    ap.add_argument("--cb_width", type=float, default=1.0,
                    help="CB window width above Ef: [Ef, Ef+cb_width]")

    ap.add_argument("--thr", type=float, default=0.99, help="cosine similarity threshold for grouping")
    ap.add_argument("--out_prefix", default="Auto", help="output prefix, e.g., TcAuto")

    ap.add_argument("--no_plot", action="store_true", help="do not output png level diagrams")

    args = ap.parse_args()

    up = load_pdos(Path(args.up))
    dw = load_pdos(Path(args.dw))

    if not np.allclose(up["E"].values, dw["E"].values, atol=1e-10):
        raise RuntimeError("Energy grids differ between UP/DW.")

    E = up["E"].to_numpy(float)

    Dup = up[D_ORBS].to_numpy(float)
    # 常见：DW 可能为负，取 abs 保持与你之前逻辑一致
    Ddw = np.abs(dw[D_ORBS].to_numpy(float))
    D = Dup + Ddw

    Ef = args.Ef
    vb_Emin, vb_Emax = Ef - args.vb_width, Ef
    cb_Emin, cb_Emax = Ef, Ef + args.cb_width

    # ===== VB =====
    vb_sim, vb_orb, vb_grp, vb_groups = compute_window(
        E, D, vb_Emin, vb_Emax, thr=args.thr, tag="VB"
    )
    vb_sim.to_csv(f"{args.out_prefix}_VB_sim_matrix.csv")
    vb_orb.to_csv(f"{args.out_prefix}_VB_orb_centers.csv", index=False)
    vb_grp.to_csv(f"{args.out_prefix}_VB_auto_groups.csv", index=False)

    # ===== CB =====
    cb_sim, cb_orb, cb_grp, cb_groups = compute_window(
        E, D, cb_Emin, cb_Emax, thr=args.thr, tag="CB"
    )
    cb_sim.to_csv(f"{args.out_prefix}_CB_sim_matrix.csv")
    cb_orb.to_csv(f"{args.out_prefix}_CB_orb_centers.csv", index=False)
    cb_grp.to_csv(f"{args.out_prefix}_CB_auto_groups.csv", index=False)

    # ===== plots =====
    if not args.no_plot:
        draw_level_diagram(
            vb_grp,
            out_png=f"{args.out_prefix}_VB_levels.png",
            title=f"{args.out_prefix}: d-level groups in VB window [{vb_Emin:.2f},{vb_Emax:.2f}] (Ef={Ef:g})",
            eref=0.0
        )
        draw_level_diagram(
            cb_grp,
            out_png=f"{args.out_prefix}_CB_levels.png",
            title=f"{args.out_prefix}: d-level groups in CB window [{cb_Emin:.2f},{cb_Emax:.2f}] (Ef={Ef:g})",
            eref=0.0
        )

    print(f"[Ef] using Ef = {Ef} eV on the PDOS energy axis.")
    print("\n[VB window]", (vb_Emin, vb_Emax), "thr=", args.thr, "groups=", vb_groups)
    print(vb_grp.to_string(index=False))

    print("\n[CB window]", (cb_Emin, cb_Emax), "thr=", args.thr, "groups=", cb_groups)
    print(cb_grp.to_string(index=False))

    print("\n[OK] Outputs:")
    print(" ", f"{args.out_prefix}_VB_sim_matrix.csv")
    print(" ", f"{args.out_prefix}_VB_orb_centers.csv")
    print(" ", f"{args.out_prefix}_VB_auto_groups.csv")
    if not args.no_plot:
        print(" ", f"{args.out_prefix}_VB_levels.png")
    print(" ", f"{args.out_prefix}_CB_sim_matrix.csv")
    print(" ", f"{args.out_prefix}_CB_orb_centers.csv")
    print(" ", f"{args.out_prefix}_CB_auto_groups.csv")
    if not args.no_plot:
        print(" ", f"{args.out_prefix}_CB_levels.png")


if __name__ == "__main__":
    main()


```

使用方法

```shell

python 1step.py --up PDOS_Tc_UP.dat --dw PDOS_Tc_DW.dat --out_prefix Tc
[Ef] using Ef = 0.0 eV on the PDOS energy axis.

```