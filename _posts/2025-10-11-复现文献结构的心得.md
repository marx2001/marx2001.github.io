---
layout: post
title: "复现文献结构的心得"
subtitle: "Experience Sharing"
background: '/img/bg-sci-note.jpg'
categories: sci-note
permalink: /sci-note_posts/20251011-F
---

# <center>摘要</center>

为了寻找合适的作为多铁异质结铁磁层的材料，准备复现一篇文献，VSeTe具有铁谷性和铁磁性，可以作为候选材料。

异质结结构优化心得体会。

本次最大收获是发现了一个复现文献结构的新思路——AI辅助法，即通过输入文献中关于结构的描述到AI中，然后让它根据格子的种类，换算成分数坐标，形成POSCAR，这样，键长、键角可以完美的与文献匹配。

**<span style="font-size: 120%"> 1. Janus单层复现文献的心得体会</span>**

复现文献结构是一个最大的问题，结构不对，基本上所有的性质都不能和文献匹配，因此得到一个正确的结构是一个艰巨的任务，今天上午，历经3个小时20分钟，终于得到了一个与文献一致的结构。下面是我的复现过程与心得体会

首先，我选择之前复现过二维铁磁半导体Janus材料的H-CrSeBr的POSCAR作为起始文件，替换POSCAR中的元素，即可得到H-VSeTe单层的初始结构，然后开始结构优化，不加磁性。我发现，并不能得到正确的结构，最多
是得到相近的结构

然后我通过固定ISIF=2，控制晶格常数不变，继续优化，但始终优化不到正确的构型中去，因此想开辟新思路，让AI写代码辅助，具体的过程如开头所示。代码如下：

```python

#!/usr/bin/env python3
"""
2H-VSeTe单层结构POSCAR生成脚本
基于文献《Predicted 2D ferromagnetic Janus VSeTe monolayer》的结构参数
Nanoscale, 2020, 12, 22735-22742
"""

import numpy as np
import math

def create_2H_VSeTe_structure():
    """
    创建2H-VSeTe单层结构的精确几何参数
    基于文献提供的结构参数和图片描述：
    - 晶格常数: a = b = 3.486 Å
    - 键长: V-Se = 2.514 Å, V-Te = 2.728 Å
    - 垂直距离: Se-V = 1.507 Å, Te-V = 1.840 Å
    - 真空层厚度: 16 Å
    - 根据图片(b)，Se和Te在x和y方向坐标相同，只有z坐标不同
    """
    
    # 文献中的精确结构参数
    a = 3.486  # 晶格常数 (Å)
    c_vacuum = 16.0  # 真空层厚度 (Å)
    
    # 六方晶系的晶格矢量
    lattice_vectors = np.array([
        [a, 0.0, 0.0],                    # a方向
        [-a/2, a * math.sqrt(3)/2, 0.0],   # b方向 (120°夹角)
        [0.0, 0.0, c_vacuum]              # c方向（真空层）
    ])
    
    # 原子种类和数量（原胞）
    elements = ['V', 'Se', 'Te']
    num_atoms = [1, 1, 1]
    
    # 精确分数坐标计算
    # V原子位于六方晶系原点，居中放置
    v_position = np.array([0.000000, 0.000000, 0.500000])
    
    # Se和Te原子位置（根据图片b，它们在x和y方向坐标相同）
    # 使用相同的x,y分数坐标
    x_pos = 1.0/3.0
    y_pos = 2.0/3.0
    
    # Se原子位置（上层）
    z_se = 0.5 + 1.507 / c_vacuum  # 基于Se-V垂直距离1.507 Å
    se_position = np.array([x_pos, y_pos, z_se])
    
    # Te原子位置（下层）
    z_te = 0.5 - 1.840 / c_vacuum  # 基于Te-V垂直距离1.840 Å
    te_position = np.array([x_pos, y_pos, z_te])
    
    # 合并所有原子位置
    positions = np.array([v_position, se_position, te_position])
    
    return lattice_vectors, elements, num_atoms, positions

def validate_structure_parameters(lattice_vectors, positions):
    """
    验证生成的结构参数是否符合文献值
    """
    print("正在进行结构参数验证...")
    
    # 转换为直角坐标进行距离计算
    def fractional_to_cartesian(frac_pos, lattice):
        return np.dot(frac_pos, lattice)
    
    v_cart = fractional_to_cartesian(positions[0], lattice_vectors)
    se_cart = fractional_to_cartesian(positions[1], lattice_vectors)
    te_cart = fractional_to_cartesian(positions[2], lattice_vectors)
    
    # 计算实际键长
    v_se_distance = np.linalg.norm(se_cart - v_cart)
    v_te_distance = np.linalg.norm(te_cart - v_cart)
    
    # 计算垂直距离
    v_se_z = abs(se_cart[2] - v_cart[2])
    v_te_z = abs(te_cart[2] - v_cart[2])
    
    # 计算水平距离（V到Se/Te投影点的距离）
    v_se_horizontal = np.linalg.norm(se_cart[:2] - v_cart[:2])
    v_te_horizontal = np.linalg.norm(te_cart[:2] - v_cart[:2])
    
    print("结构参数验证结果:")
    print(f"  晶格常数 a = {np.linalg.norm(lattice_vectors[0]):.6f} Å, b = {np.linalg.norm(lattice_vectors[1]):.6f} Å")
    print(f"  真空层厚度 = {lattice_vectors[2,2]:.1f} Å")
    print(f"  V-Se键长 = {v_se_distance:.3f} Å (文献值: 2.514 Å)")
    print(f"  V-Te键长 = {v_te_distance:.3f} Å (文献值: 2.728 Å)")
    print(f"  Se-V垂直距离 = {v_se_z:.3f} Å (文献值: 1.507 Å)")
    print(f"  Te-V垂直距离 = {v_te_z:.3f} Å (文献值: 1.840 Å)")
    print(f"  V-Se水平距离 = {v_se_horizontal:.3f} Å")
    print(f"  V-Te水平距离 = {v_te_horizontal:.3f} Å")
    
    # 检查Se和Te的x,y坐标是否相同
    se_xy = positions[1][:2]
    te_xy = positions[2][:2]
    xy_same = np.allclose(se_xy, te_xy, atol=1e-6)
    print(f"  Se和Te的x,y坐标是否相同: {xy_same}")
    if xy_same:
        print(f"  Se/Te共同x,y坐标: ({se_xy[0]:.6f}, {se_xy[1]:.6f})")
    
    # 检查偏差
    tolerances = [0.001, 0.01, 0.01, 0.001, 0.001]
    targets = [3.486, 2.514, 2.728, 1.507, 1.840]
    actuals = [np.linalg.norm(lattice_vectors[0]), v_se_distance, v_te_distance, v_se_z, v_te_z]
    
    all_valid = True
    for i, (target, actual, tol) in enumerate(zip(targets, actuals, tolerances)):
        deviation = abs(actual - target)
        if deviation > tol:
            print(f"  警告: 参数{i+1}偏差 {deviation:.3f} Å > 容限 {tol} Å")
            all_valid = False
    
    return all_valid

def write_POSCAR(filename, lattice_vectors, elements, num_atoms, positions):
    """
    写入标准VASP格式的POSCAR文件
    """
    with open(filename, 'w') as f:
        # 文件头
        f.write("2H-VSeTe Janus Monolayer - Generated from literature parameters\n")
        f.write("1.0\n")
        
        # 晶格矢量
        for vector in lattice_vectors:
            f.write(f"    {vector[0]:16.10f}    {vector[1]:16.10f}    {vector[2]:16.10f}\n")
        
        # 元素行
        f.write("   " + "   ".join(elements) + "\n")
        
        # 原子数量行
        f.write("   " + "   ".join(map(str, num_atoms)) + "\n")
        
        # 坐标类型
        f.write("Direct\n")
        
        # 原子坐标
        for pos in positions:
            f.write(f"    {pos[0]:16.10f}    {pos[1]:16.10f}    {pos[2]:16.10f}\n")

def main():
    """
    主函数：生成2H-VSeTe POSCAR文件
    """
    print("=" * 70)
    print("2H-VSeTe单层结构POSCAR生成器")
    print("基于文献: Nanoscale, 2020, 12, 22735-22742")
    print("和图片(b)的结构信息")
    print("=" * 70)
    
    # 生成2H-VSeTe结构
    print("正在生成2H-VSeTe单层结构...")
    print("注意: 根据图片(b)，Se和Te在x和y方向具有相同坐标")
    lattice_vectors, elements, num_atoms, positions = create_2H_VSeTe_structure()
    
    # 验证结构参数
    print("\n" + "-" * 70)
    is_valid = validate_structure_parameters(lattice_vectors, positions)
    
    # 写入POSCAR文件
    output_file = "POSCAR_2H_VSeTe"
    write_POSCAR(output_file, lattice_vectors, elements, num_atoms, positions)
    
    print("\n" + "-" * 70)
    print(f"✓ POSCAR文件已成功生成: {output_file}")
    print(f"✓ 结构类型: 2H-VSeTe Janus单层")
    print(f"✓ 原胞包含: {sum(num_atoms)} 个原子 ({' + '.join([f'{n}{e}' for e, n in zip(elements, num_atoms)])})")
    print(f"✓ 晶格常数: a = b = {np.linalg.norm(lattice_vectors[0]):.3f} Å")
    print(f"✓ 真空层厚度: {lattice_vectors[2,2]:.1f} Å")
    print(f"✓ 结构特征: Se和Te在x,y平面投影重合，只有z坐标不同")
    
    # 结构说明
    print("\n" + "=" * 70)
    print("修改后的结构说明")
    print("=" * 70)
    
    print("根据图片(b)的信息，我们对结构进行了以下调整:")
    print("1. Se和Te原子现在具有相同的x和y分数坐标")
    print("2. 只有z坐标不同，形成垂直堆叠的Janus结构")
    print("3. V原子位于中间层，Se在上层，Te在下层")
    print("4. 这种排列保持了文献报道的键长和垂直距离")
    
    print("\n几何关系:")
    print("  • V原子: 位于晶格中心 (0,0,0.5)")
    print("  • Se原子: 位于(1/3,2/3,z_se)，z_se > 0.5")
    print("  • Te原子: 位于(1/3,2/3,z_te)，z_te < 0.5")
    print("  • Se和Te在xy平面投影重合，形成垂直Janus结构")
    
    print("\n" + "=" * 70)
    print("POSCAR文件已准备就绪，可直接用于VASP计算")
    print("=" * 70)

if __name__ == "__main__":
    main()

```

虽然这个脚本比较呆板，但也是解决了我当下的问题。

**<span style="font-size: 120%"> 2. 异质结结构优化的心得体会</span>**


异质结结构优化是一个巨大的问题，因为漫长且充满了不确定性——畸变随时可能发生。我做了MnSeTe和拓扑绝缘体VTeCl与Zr2Ge2Te6的异质结，晶格失配率约为0.05%。其结构优化共同的问题是，会发生严重的畸变，变成1T'相的Janus结构。

ISIF=2和ISIF=3的结构优化均不能解决该问题。大概只能通过寻找不畸变的异质结才能解决问题。上述两种异质结畸变之后，由半导体变为金属，性质变化剧烈且并无特殊性质出现。